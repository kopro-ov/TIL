| 내용 | 최초 작성일 | 참고 |
|---|:---:|---:|
| 리팩터링 첫 번째 예시 | 2021-08-04 | 리팩터링 2판 |
# 리팩터링: 첫 번째 예시
원칙은 지나치게 일반화되기 쉬워서 실제 적용 방법을 파악하기 어렵지만 예시가 있으면 모든 게 명확해진다.  
이 책은 리팩터링을 실제로 해보는 예를 책 앞쪽에 배치했다.  
그래서 저자가 선보이는 리팩터링 과정을 따라오면서 리팩터링을 어떻게 수행하는지 감 잡을 수 있다.  
하지만, 프로그램이 너무 길면 코드를 설명하고 리팩터링하는 과정이 너무 복잡해서 코드가 짧다고 한다.  
그래서 항시 책의 예시들이 대규모 시스템에서 발췌한 코드라고 상상하면서 따라오길 권장한다.  
이러한 연상 방식은 실전용 기법을 제한된 지면으로 설명하려 할 때 많이들 활용하는 기법이다.  
리팩터링은 내부 동작을 이해해야 할 시점에 해야 효과를 제대로 볼 수 있다.!!?
# 1 자! 시작해보자.
요구사항
```
다양한 연극을 위주로 받아서 공연하는 극단이 있다.
공연 요청이 들어오면 연극의 장르와 관객 규모를 기초로 비용을 책정한다.
현재 이 극단은 두 가지 장르, 비극과 희극만 공연한다.
그리고 공연료와 별개로 포인트를 지급해서 다음번 의뢰 시 공연료를 할인받을 수 있다.
```
일종의 충성도 프로그램인 셈이다.  
극단은 공연할 연극 정보를 다음과 같이 간단한 json파일에 저장한다.
**plays.json**
```json
{
    "hamlet": {"name": "Hamlet", "type": "tragedy"},
    "as-like": {"name": "As You Like It", "type": "comedy"},
    "othello": {"name": "Othello", "type": "tragedy"},
}
```
공연료 청구서에 들어갈 데이터도 다음과 같이 JSON 파일로 표현한다.
**invocies.json**
```json
[
    {
        "customer": "BigCo",
        "performances": [
            {
                "playID": "hamlet",
                "audience": 55
            },
            {
                "playID": "as-like",
                "audience": 35
            },
            {
                "playID": "othello",
                "audience": 40
            }            
        ]
    }
]
```
공연료 청구서를 출력하는 코드는 다음과 같이 간단히 함수로 구현했다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch (play.type) {
            case "tragedy": //비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case "comdedy":
                thisAmount = 30000;
                if (perf.audience > 20) {
                    this.Amount += 10000 + 500 * (perf.audience - 20);
                }
                thisAmount += 300 * perf.audience;
                break;
            default:
                throw new Error('알 수 없는 장르: ${play.type}');
        }

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        result += ' ${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
이 책 저자는 프로그램이 너무 짧아서 특별히 애써 이해해야 할 구조도 없다고 한다.  
그래서 처음에 이야기한 것 처럼 이 책에서는 이처럼 짧은 예만 소개한다.  
하지만 이런 코드가 수백 줄짜리 프로그램의 일부라면 간단한 인라인 함수 하나라도 이해하기 쉽지 않다.  
프로그램이 잘 작동하는 상황에서 그저 코드가 '지저분하다'는 이유로 불평하는 것은 프로그램의 구조를 너무 미적인 기준으로만 판단하는 건 아닐까? 컴파일러는 코드가 깔끔하든 지저분하든 개의치 않으니 말이다.  
하지만 그 코드를 수정하려면 사람이 개입되고, 사람은 코드의 미적 상태에 민감하다.  
설계가 나쁜 시스템은 수정하기 어렵다. 원하는 동작을 수행하도록 하기 위해 수정해야 할 부분을 찾고, 기존 코드와 잘 맞물려 작동하게 할 방법을 강구하기가 어렵기 때문이다.  
그래서 무엇을 수정할지 찾기 어렵다면 실수를 저질러서 버그가 생길 가능성도 높다.  
이 책의 저자는 수백 줄짜리 코드를 수정할 때면 먼저 프로그램의 작동 방식을 더 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다.  
프로그램의 구조가 빈약하다면 대체로 구조부터 바로잡은 뒤에 기능을 수정하는 편이 작업하기가 훨씬 수월하다.  
> 프로그램이 새로운 기능을 추가하기에 편한 구조가 아니라면, 먼저 기능을 추가하기 쉬운 형태로 리팩터링하고 나서 원하는 기능을 추가해라.
위의 소스에 사용자의 입맛에 맞게 수정할 부분은 아래와 같다.
1. 가장 먼저 청구 내역을 HTML로 출력하는 기능이 필요하다.  
    **이 부분이 어느 부분에 영향을 주는가?**
    ```
    HTML태그를 삽입해야 하니 청구 결과에 문자열 추가하는 문장 각각을 조건문으로 감싸야 한다. 
    그러면 statement() 함수의 복잡도가 크게 증가한다. 
    이런 상황이라면 대부분 이 함수의 복사본을 만들고 복사본에 HTML을 출력하는 식으로 처리한다.
    이때 복사하는 일 자체는 그리 부담되지 않지만 나중에 수많은 문제를 일으킬 여지가 있다.
    청구서 작성 로직을 변경할 때마다 기존 함수와 HTML버전 함수 모두를 수정하고, 항시 일관되게 수정했는지도 확인해야한다.
    로직을 변경할 일이 절대 없다면 이렇게 복사해서 붙이는 방식도 상관 없지만, 오래 사용할 프로그램이라면 중복 코드는 골칫거리가 된다.
    ```
2. 변경 사항과도 관련이 있다.  
배우들은 사극, 전원극, 전원 희극, 역사 전원극, 역사 비극, 희비 역사 전원극, 장면 변화가 없는 고전극, 길이와 시간 장소에 제약 없는 자유극 등 더 많은 장르르 연기하고 싶어 한다. 언제 어떤 연극을 할지는 아직 결정하지 못했지만, 이 변경은 공연료와 적립 포인트 계산법에 영향을 줄 것이다.  
이처럼 연극 장르와 공연료 정책이 달라질 떄마다 statement()함수를 수정해야 한다.  
만약 statement()를 복사해서 별도의 htmlStatement()를 만든다면 모든 수정이 두 함수에 일관되게 반영되도록 보장해야하며 정책이 복잡해질수록 수정할 부분을 찾기 어려워지고 수정 과정에서 실수할 가능성도 커진다.  
**그래서 리팩터링이 필요한 이유는 바로 이러한 변경 때문이다.**
잘 작동하고 나중에 변경할 일이 절대없다면 코드를 현재 상태로 놔둬도 아무런 문제가 없다.  
더 다듬어두면 물론 좋겠지만, 누군가 코드를 읽지 않는 한 아무런 피해가 없다.  
하지만 그러다 다른 사람이 읽고 이해해야 할 일이 생겼는데 로직을 파악하기 어렵다면 뭔가 대책을 마련해야한다.
# 리팩터링의 첫 단계
리팩터링의 첫 단계는 항상 똑같다.  
리팩터링할 코드 영역을 `꼼꼼하게 검사해줄 테스트 코드들 부터 마련해야 한다.`  
리팩터링에서 테스트의 역할은 굉장히 중요하다. 리팩터링 기법들이 버그 발생 여지를 최소화하도록 구성됐다고는 하나 실제 작업은 사람이 수행하기 때문에 언제든 실수할 수 있다.  
프로그램이 클수록 수정 과정에서 예상치 못한 문제가 발생할 가능성이 크다.  
**statement()**함수의 테스트는 어떻게 구성하면 될까?  
함수가 문자열을 반환하므로 다양한 장르의 공연들로 구성된 공연료 청구서 몇 개를 미리 작성하여 문자열 형태로 준비해준다.  
그런 다음 statement()가 반환한 문자열과 준비해둔 정답 문자열을 비교한다.  
그리고 테스트 프레임워크를 이용하여 모든 테스트를 단축키 하나로 실행할 수 있도록 설정해준다.  
테스트 시 성공/실패를 스스로 판단하는 자가진단 테스트로 만들어야 한다. 자가진단 여부는 중요하다.  
그래서 최신 테스트 프레임워크는 자가진단 테스트를 작성하고 실행하는데 필요한 모든 기능을 제공한다.
> 리팩터링하기 전에 제대로 된 테스트부터 마련한다. 테스트는 반드시 자가진단하도록 만든다.
리팩터링 시 테스트는 개발자가 저지른 실수부터 보호해주는 버그 검출기 역할을 해준다. 
# 4. statement() 함수 쪼개기.
statement()처럼 긴 함수를 리팩터링할 때는 먼저 전체 동작을 각각의 부분으로 나눌 수 있는 지점을 찾는다.  
switch문에 주목해라.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = 0;

        switch (play.type) {
            case "tragedy": //비극
                thisAmount = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case "comdedy":
                thisAmount = 30000;
                if (perf.audience > 20) {
                    this.Amount += 10000 + 500 * (perf.audience - 20);
                }
                thisAmount += 300 * perf.audience;
                break;
            default:
                throw new Error('알 수 없는 장르: ${play.type}');
        }

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        result += ' ${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
switch문을 살펴보면 한 번의 공연에 대한 요금을 계산한다.  
이러한 사실은 코드를 분석해서 얻은 정보다. 이런 식으로 파악한 정보는 휘발성이 높기로 악명 높은 저장 장치인 내 머릿속에 기록되므로, 잊지 않으려면 재빨리 코드에 반영해야 한다.  
그러면 다음번에 코드를 볼 때, 다시 분석하지 않아도 코드 스스로가 자신이 하는 일이 무엇인지 이야기 해준다.  
코드 조각을 별도 함수로 추출하는 방식으로 앞서 파악한 정보를 코드에 반영한다.  
추출한 함수에는 그 코드가 하는 일을 설명하는 이름을 지어준다. **amountFor(aPerformance)**  
이렇게 코드 조각을 함수로 추출할 때 실수를 최소화해주는 절차를 마련한다.(6.1절을 봐야함)  
이렇게 별도 함수로 빼냈을 때 유효 범위를 벗어나는 변수, 즉 새 함수에서 곧바로 사용할 수 없는 변수가 있는지 확인한다.  
이 코드에서는 perf, play, thisAmount가 여기 속한다. perf와 play는 추출한 새 함수에서도 필요하지만 값을 변경하지 않기 때문에 매개변수로 전달하면 된다.  
thisAmount는 함수 안에서 값이 바뀌는데, 이런 변수는 조심해서 다뤄야 한다.  
이번예에는 이런 변수가 하나뿐이므로 이 값을 반환하도록 작성한다.  
또한 이 변수를 초기화하는 코드도 추출한 함수에 넣었다.
```javascript
function amountFor(perf, play) { //값이 바뀌지 않는 변수는 매개 변수로 전달한다.
    lef thisAmount = 0; //함수 안에서 값이 바뀐 변수였기 때문에 변수를 초기화하는 코드를 넣었다. 
    switch (play.type) {
        case "tragedy": //비극
            thisAmount = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case "comdedy":
            thisAmount = 30000;
            if (perf.audience > 20) {
                this.Amount += 10000 + 500 * (perf.audience - 20);
            }
            thisAmount += 300 * perf.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return thisAmount; //함수 안에서 값이 바뀌는 변수 반환
}
```
이제 statement()에서는 thisAmount값을 채울 때 방금 추출한 amountFor() 함수를 호출한다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {
        const play = plays[perf.playID];
        let thisAmount = amountFor(perf, play); //추출한 함수를 이용!

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        result += ' ${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
이렇게 수정하고 나면 바로 테스트한다.  `아무리 간단한 수정이라도 리팩터링 후에는 항상 테스트하는 습관을 들이는 것이 바람직하다.`  
> 리팩터링은 프로그램 수정을 작은 단계로 나눠 진행한다. 그래서 중간에 실수하더라도 버그를 쉽게 찾을 수 있다.
- 자바스크립트를 포함하여 일부 언어세너는 함수 안에 함수를 정의할 수 있다. 다른 클래스 안에 정의하는 중첩 클래스(내부 클래스)의 함수 버전이라고 생각하면 된다. 내부 클래스에서 바깥 클래스의 자원(변수, 메서드 등)에 접근할 수 있듯이, 내부 함수에서도 바깥 함수의 자원(변수, 함수 등) 접근할 수 있다.
중첩 함수로 만들면 할 일 하나가 줄어든다.  
하나의 리팩터링을 문제없이 끝낼 때마다 커밋한다. 그래야 중간에 문제가 생기더라도 이전의 정상 상태로 쉽게 돌아갈 수 이싿.  
`함수 추출하기는 흔히 IDE에서 자동으로 수행`해준다. 자바로 프로그래밍할 때는 거의 본능적으로 함수 추출 리팩터링에 해당하는 단축키를 누른다.  
***지역변수의 유효범위 문제만 조심하면 수동으로 해도 어려울 건 없다!***  
```
리펙토링 중에, 간단하면서도 강력한 방법이 Extract Method

메소드가 길다고 무조건 메소드 추출을 할 것이 아니라, 메소드 내에서 역할을 잘 생각해보고 하는 것이 좋다. 예를 들면, 메소드 내에서 계산하는 부분과 출력하는 부분이 같이 존재한다면, 계산과 출력은 다른 역할로 볼 수 있으므로 메소드 추출이 가능하다.
```
IDE 단축키 
- 이클립스 : ALT+SHIFT+M  
- vscode : [링크](https://dayjms.tistory.com/entry/%EB%B9%84%EC%A3%BC%EC%96%BC-%EC%8A%A4%ED%8A%9C%EB%94%94%EC%98%A4-%EC%BD%94%EB%93%9C%EC%9D%98-11%EA%B0%80%EC%A7%80-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EA%B8%B0%EB%8A%A5-1-%EB%A9%80%ED%8B%B0%EC%BB%A4%EC%84%9C-%EC%97%90%EB%94%94%ED%8C%85MultiCursor-Editing)

함수를 추출하고 나면 추출된 함수 코드를 자세히 들여다보면서 지금보다 명확하게 표현할 수 있는 간단한 방법은 없는지 검토한다.  
가장 먼저 변수의 이름을 더 명확하게 바꿔본다. 가령 thisAMount->result로
```javascript
function amountFor(perf, play) { //값이 바뀌지 않는 변수는 매개 변수로 전달한다.
    lef result = 0; //함수 안에서 값이 바뀐 변수였기 때문에 변수를 초기화하는 코드를 넣었다. 
    switch (play.type) {
        case "tragedy": //비극
            result = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case "comdedy":
            result = 30000;
            if (perf.audience > 20) {
                this.Amount += 10000 + 500 * (perf.audience - 20);
            }
            result += 300 * perf.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return result; 
}
```
함수의 반환 값에는 항상 result을 쓴다. 그러면 그 변수의 역할을 쉽게 알 수 있다.  
다음은 첫 번째 인수인 perf를 aPerformance로 리팩터링 해본다.
```javascript
function amountFor(aPerformance, play) { //명확한 이름으로 변경.
    lef result = 0; 
    switch (play.type) {
        case "tragedy": //비극
            result = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case "comdedy":
            result = 30000;
            if (perf.audience > 20) {
                this.Amount += 10000 + 500 * (perf.audience - 20);
            }
            result += 300 * perf.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return result; 
}
```
자바스크립트와 같은 동적 타입 언어를 사용할 때는 타입이 드러나게 작성하면 도움이 된다.  
그래서 매개변수 이름에 접두어로 타입 이름을 적는데, 지금처럼 매개변수의 역할이 뚜렷하지 않을 때는 부정 관사(a/an)를 붙인다.  
> 컴퓨터가 이해하는 코드는 바보도 작성할 수 있다. 사람이 이해하도록 작성하는 프로그래머가 진정한 실력자다.
좋은 코드라면 하는 일이 명확히 드러나야하며, 이때 변수 이름은 커다란 역할을 한다. 그러니 명확성을 높이기 위한 이름 바꾸기에는 조금도 망설이지 말아야한다.  
'찾아 바꾸기' 기능을 제공하는 도구를 사용하면 어렵지도 않다.  
준비해둔 테스트가 있다면, 그리고 정적 타입 언어를 사용한다면, 여러분이 미처 발견하지 못한 부분까지 찾아준다.  
자동 리팩터링 도구를 사용한다면 호출하는 곳이 아주 많은 함수의 이름도 아주 쉽게 바꿀 수 있다.  
다음으로 play매개변수의 이름을 바꿀 차례다.
## play 변수제거
play변수는 좀 다르게 처리해야한다. amountFor()의 매개변수를 살펴보면서 이 값들이 어디서 오는지 알아봤다.  
aPerformance는 루프 변수에서 오기 때문에 반복문을 한 번 돌 때마다 자연스레 값이 변경된다. 하지만 play는 개별 공연(aPerformance)에서 얻기 때문에 애초에 매개변수로 전달할 필요가 없다.  
aomountFor()안에서 다시 play를 계산하면 된다. 긴 함수를 잘게 쪼갤 때마다 play같은 변수를 최대한 제거해야한다.  
이런 임시 변수들 때문에 로컬 범위에 존재하는 이름이 늘어나서 추출 작업이 복잡해진다.  
이를 해결해주는 리팩터링으로는 **임시 변수를 질의 함수로 바꾸기(7.4절)**가 있다.  
먼저 대입문(=)의 우변을 함수로 추출한다.
```javascript
function playFor(aPerformance) {
    return plays[aPerformance.playID];
}
```
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {
        const play = playFor(perf); //우변을 함수로 추출!
        let thisAmount = amountFor(perf, play); 

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        result += ' ${play.name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
**변수 인라인하기(6.4)**을 적용한다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {
        //const play = playFor(perf); > 인라인된 변수는 제거!
        let thisAmount = amountFor(perf, play); 

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        //아래가 변수 인라인!!!
        result += ' ${playFor(perf).name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
이렇게 변수를 인라인한 덕분에 amountFor()에 함수 선언 바꾸기(6.5절)를 적용해서 play매개 변수를 제거할 수 있게 되었다.  
이 작업은 두 단계로 진행한다.
1. 새로 만든 playFor()를 사용하도록 amountFor()를 수정한다.
2. 컴파일-테스트-커밋하고 play매개 변수를 삭제한다.
그러면 새로 만든 playFor()를 사용하도록 amountFor()를 수정한다.
```javascript
function amountFor(aPerformance, play) { //명확한 이름으로 변경.
    lef result = 0; 
    switch (playFor(aPerformance).type) {  //[변경내용] play를 playFor()호출로 변경!!
        case "tragedy": //비극
            result = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case "comdedy":
            result = 30000;
            if (perf.audience > 20) {
                this.Amount += 10000 + 500 * (perf.audience - 20);
            }
            result += 300 * perf.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return result; 
}
```
그 다음 컴파일-테스트-커밋하고 play매개변수를 삭제한다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {

        let thisAmount = amountFor(perf); //[변경내용] 필요 없어진 매개변수 제거

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        //청구 내역을 출력한다.
        //아래가 변수 인라인!!!
        result += ' ${playFor(perf).name}: ${format(thisAmount / 100)} (${perf.audience}석)\n';
        totalAmount += thisAmount;
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
```javascript
function amountFor(aPerformance) { //[변경내용] 필요 없어진 매개변수 제거
    lef result = 0; 
    switch (playFor(aPerformance).type) {
        case "tragedy": //비극
            result = 40000;
            if (perf.audience > 30) {
                thisAmount += 1000 * (perf.audience - 30);
            }
            break;
        case "comdedy":
            result = 30000;
            if (perf.audience > 20) {
                this.Amount += 10000 + 500 * (perf.audience - 20);
            }
            result += 300 * perf.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return result; 
}
```
그리고 컴파일-테스트-커밋한다.  
방금 수행한 리팩터링에서 주목할 점이 몇 가지 있다.  
이전 코드는 루프를 한 번 돌 때마다 공연을 조회했는데 반해 리팩터링한 코드에서는 세 번이나 조회한다.  
여기에서 리팩터링과 성능의 관계는 자세히 설명할 순 없지만, 지금 확인한 바로는 이렇게 변경해도 성능에 큰 영향은 없다.  
설사 심각하게 느려지더라도 제대로 리팩터링된 코드베이스는 그렇지 않은 코드보다 성능을 개선하기가 훨씬 수월하다.
**지역 변수를 제거**해서 얻는 가장 큰 장점은 추출 작업이 훨씬 쉬워진다는 것이다.  
**그 이유는 유효범위를 신경 써야 할 대상이 줄어들기 때문이다.**
다시 함수를 호출하는 코드로 돌아가보면 여기서 amountFor()는 임시 변수인 thisAmount에 값을 설정하는 데 사용되는데, 그 값이 다시 바뀌지 않는다. 따라서 변수 인라인하기(6.4절)를 적용한다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        result += ' ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n'; //[변경 내용] thisAmount 변수를 인라인
        totalAmount += amountFor(perf); //[변경 내용] thisAmount 변수를 인라인
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
## 적립 포인트 계산 코드 추출하기
지금까지 statement()함수를 리팩터링한 결과는 다음과 같다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {

        //포인트를 적립한다.
        volumeCredits += Math.max(perf.audience - 30, 0);
        //희극 관객 5명마다 추가 포인트를 제공한다.
        if("comedy" === play.type) volumeCredits += Math.floor(perf.audience / 5);

        result += ' ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
앞에서 play변수를 제거한 결과 로컬 유효범위의 변수가 하나 줄어서 적립 포인트 계산 부분을 추출하기가 훨씬 쉬워졌다.  
하지만 처리해야 할 변수가 아직 두개 더 남아있다. 여기서도 perf는 간단히 전달만 하면 된다.  
하지만 volumeCredits는 반복문을 돌 때마다 값을 누적해야 하기 때문에 살짝 더 까다롭다.  
이 상황에서 최선의 방법은 추출한 함수에서 volumeCredits의 복제본을 초기화한 뒤 계산 결과를 반환토록 하는 것이다.
```javascript
function volumeCreditsFor(perf) {
    let volumeCredits += Math.max(perf.audience - 30,0);
    if ("comedy" === playFor(perf).type) 
        volumeCredits += Math.floor(perf.audience / 5);
    return volumeCredits;
}
```
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {

        volumeCredits += volumeCreditsFor(perf); //[변경 내용] 추출한 함수를 이용해 값을 누적

        result += ' ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
필요 없어진 주석은 지워라. 남겨 두면 오히려 오해의 소지가 있다.  
컴파일-테스트-커밋한 다음, 새로 추출한 함수에서 쓰이는 변수들 이름을 적절히 바꿔라.
```javascript
function volumeCreditsFor(aPerformance) {
    let result += Math.max(aPerformance.audience - 30,0);
    if ("comedy" === playFor(aPerformance).type) 
        result += Math.floor(aPerformance.audience / 5);
    return result;
}
```
## format 변수 제거하기
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';
    const format = new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

    for (let perf of invoice.performances) {

        volumeCredits += volumeCreditsFor(perf); //[변경 내용] 추출한 함수를 이용해 값을 누적

        result += ' ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
앞에서 설명했듯이 임시 변수는 나중에 문제를 일으킬 수 있다.  
임시 변수는 자식이 속한 루틴에서만 의미가 있어서 루틴이 길고 복잡해지기 쉽다.  
따라서 다음으로 할 리팩터링은 이런 변수들을 제거하는 것이다.  
그중에서 format이 만만해 보인다. format은 임시 변수에 함수를 대입한 형태인데, 
함수를 직접 선언해 사용하도록 바꿔본다.
```javascript
function format(aNumber) {
    return new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format;

}
```
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        volumeCredits += volumeCreditsFor(perf); 

        result += ' ${playFor(perf).name}: ${format(amountFor(perf) / 100)} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    result += '총액: ${format(totalAmount/100)}\n';
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
> 이처럼 함수 변수를 일반 함수로 변경하는 것도 리팩터링이지만, 따로 이름을 붙여 리팽터링 목록에 넣진 않았다. 굉장히 간단한 데다 드물게 쓰이기 때문이다. 
하지만 이름이 마음에 걸린다. "format"은 이 함수가 하는 일을 충분히 설명해주지 못한다.  
템플릿 문자열 안에서 사용될 이름이라서 "foramtAsUSD"라고 하기엔 또 너무 장황하다.  
그럴땐 함수의 핵심을 생각해보면 된다. 이 함수의 핵심은 화폐 단위 맞추기다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        volumeCredits += volumeCreditsFor(perf); 

        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    result += '총액: ${usd(totalAmount)}\n'; //단위 변환 로직도 이 함수 안으로 이동한다.
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
```javascript
function usd(aNumber) {
    return new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format(aNumber/100);
}
```
이름짓기는 중요하면서도 쉽지 않은 작업이다.  
긴 함수를 작게 쪼개는 리팩터링은 이름을 잘 지어야만 효과가 있다. 이름이 좋으면 함수 본문을 읽지 않고도 무슨 일을 하는지 알 수 있다.  
따라서 처음에는 당장 떠오르는 최선의 이름을 사용하다가, 나중에 더 좋은 이름이 떠오를 때 바꾸는 식이 좋다.  
흔히 코드를 두 번 이상 읽고 나서야 가장 적합한 이름이 떠오르곤 한다.  
## volumeCredits 변수 제거하기.
다음으로 살펴볼 변수는 volumeCredits다.  
이 변수는 반복문을 한 바퀴 돌 때마다 값을 누적하기 때문에 리팩터링하기가 더 까다롭다.  
따라서 먼저 반복문 쪼개기(8.7절)로 volumeCredits값이 누적되는 부분을 따로 뺴낸다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let volumeCredits = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        // 청구 내역을 출력한다.
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }
    for (let perf of invoice.performances) { //[변경내용] 값 누적 로직을 별도로 for문으로 분리.
        volumeCredits += volumeCreditsFor(perf);  
    }
    
    result += '총액: ${usd(totalAmount)}\n'; 
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
이어서 문장 슬라이드(8.6절)을 적용해서 volumeCredits변수를 선언하는 문장을 반복문 바로 앞으로 옮긴다.
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        // 청구 내역을 출력한다.
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }

    let volumeCredits = 0; //[변경내용] 변수를 선언하는 문장을 반복문 바로 앞으로
    for (let perf of invoice.performances) { 
        volumeCredits += volumeCreditsFor(perf);  
    }
    
    result += '총액: ${usd(totalAmount)}\n'; 
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
volumeCredits 값 갱신과 관련한 문장들을 한데 모아두면 임시 변수를 질의 함수로 바꾸기(7.4절)가 수월해진다.  
volumeCredits값 계산 코드를 함수로 추출(6.1절)하는 작업부터 한다.
```javascript
function totalVolumeCredits() {
    let volumeCredits = 0;
    for (let perf of invoice.performances) { 
        volumeCredits += volumeCreditsFor(perf);  
    }    
}
```
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        // 청구 내역을 출력한다.
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }

    let volumeCredits = totalVolumeCredits(); //값 계산 로직을 함수로 추출
    
    result += '총액: ${usd(totalAmount)}\n'; 
    result += '적립 포인트: ${volumeCredits}점\n';
    return result;
}
```
함수 추출이 끝났다면, 다음은 volumeCredits 변수를 인라인 할 차례다. 
```javascript
function statement(invoice, plays) {
    let totalAmount = 0;
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {

        // 청구 내역을 출력한다.
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
        totalAmount += amountFor(perf); 
    }

    result += '총액: ${usd(totalAmount)}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n'; //[변경 내용] 변수 인라인
    return result;
}
```
반복문을 쪼개서 성능이 느려지지 않을까 걱정할 수 있다.  
이처럼 반복문이 중복되는 것을 꺼리는 이들이 많지만, 이 정도 중복은 성능에 미치는 영향이 미미할 때가 많다.  
똑똑한 컴파일러들은 최신 캐싱 기법 등으로 무장하고 있어서 우리의 직관을 초월하는 결과를 내어주기 떄문이다. 그래서 경험 많은 프로그래머조차 코드의 실제 성능을 정확히 예측하지 못한다. 또한 소프트웨어 성능은 대체로 코드의 몇몇 작은 부분에 의해 결정되므로 그 외의 부분은 수정한다고 해도 성능 차이를 체감할 수 없다.  
하지만 `'대체로 그렇다'`와 `'항상 그렇다'`는 엄연히 다르다. 떄로는 리팩터링이 성능에 상당한 영향을 주기도 한다.  
하지만 책 저자는 개의치 않고 리팩터링을 한다고 한다. 잘 다듬어진 코드라야 성능 개선 작업도 훨씬 수월하기 때문이다.  
리팩터링 과정에서 성능이 크게 떨어졌다면 리팩터링 후 시간을 내어 성능을 개선한다. 이 과정에서 리팩터링된 코드를 예전으로 되돌리는 경우도 있지만 대체로 리팩터링 덕분에 성능 개선을 더 효과적으로 수행할 수 있기 때문에 결과적으로 더 깔끔하면서 더 빠른 코드를 얻게 된다.  
volumeCredits 변수를 제거하는 작업의 단계를 아주 잘게 나눴다는 점에 주목하자.  
다음과 같이 총 네 단계로 수해했으며 각 단계마다 컴파일-테스트하고 로컬 저장소에 커밋했다.
1. 반복문 쪼개기(8.7)로 변수 값을 누적시키는 부분을 분리한다.
2. 문장 슬라이드(8.6)로 변수 초기화 문장을 변수 값 누적 코드 바로 앞으로 옮긴다.
3. 함수 추출하기(6.1)로 적립 포인트 계산 부분을 별도 함수로 추출한다.
4. 변수 인라인하기(6.4)로 volumeCredits 변수를 제거한다.
코드가 복잡할수록 단계를 작게 나누면 작업 속도가 빨라진다.  
다음으로 totalAmount도 앞에서와 똑같은 절차로 제거한다. 먼저 반복문을 쪼개고, 변수 초기화 문장을 옮긴 다음, 함수를 추출한다.  
추출할 함수의 이름은 totalAmount가 가장 좋지만 이미 같은 이름의 변수가 있어서 쓸 수 없다.  
그래서 일단 아무 이름인 appleSauce를 붙여준다 (?)
```javascript
function appleSauce() {
    let totalAmount = 0;
    for (let perf of invoice.performances) {
        totalAmount += amountFor(perf);
    }
    return totalAmount;
}
```
```javascript
function statement(invoice, plays) {
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    let = totalAmount = appleSauce(); //함수 추출 & 임시 이름 부여

    result += '총액: ${usd(totalAmount)}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;
}
```
이제 totalAmount 변수를 인라인한 다음 컴파일 테스트 커밋.!!!  
그리고 함수 이름을 더 의미있게 고쳐보자!
```javascript
function statement(invoice, plays) {
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; //변수 인라인 후 함수 이름 바꾸기!
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;
}
```
추출한 함수 안에서 쓰인 이름들도 변경하자!
```javascript
function totalAmount() {
    let result = 0;
    for (let perf of invoice.performances) {
        result += amountFor(perf);
    }
    return result;
}

function totalVolumeCredits() {
    let result = 0;
    for (let perf of invoice.performances) { 
        result += result(perf);  
    }    
}
```
# 5. 중간 점검! 난무하는 중첩 함수
여기까지 잠시 멈춰 서서 지금까지 리팩터링한 결과를 보자.
```javascript

function statement(invoice, plays) {
    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;

    //여기서부터 중첩 함수 시작!
    function totalAmount() {
        let result = 0;
        for (let perf of invoice.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of invoice.performances) { 
            result += result(perf);  
        }    
    }

    function usd(aNumber) {
        return new Intl.NumberFormat("en-US",
                            { style: "currency", currency: "USD",
                            minimumFractionDigits: 2 }).format(aNumber/100);
    }

    function volumeCreditsFor(perf) {
        let volumeCredits += Math.max(perf.audience - 30,0);
        if ("comedy" === playFor(perf).type) 
            volumeCredits += Math.floor(perf.audience / 5);
        return volumeCredits;
    }

    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }

    function amountFor(aPerformance) { 
        lef result = 0; 
        switch (playFor(aPerformance).type) {
            case "tragedy": //비극
                result = 40000;
                if (perf.audience > 30) {
                    thisAmount += 1000 * (perf.audience - 30);
                }
                break;
            case "comdedy":
                result = 30000;
                if (perf.audience > 20) {
                    this.Amount += 10000 + 500 * (perf.audience - 20);
                }
                result += 300 * perf.audience;
                break;
            default:
                throw new Error('알 수 없는 장르: ${play.type}');
        }
        return result; 
    }  //amountFor()끝!
} //statement() 끝!!!
```
코드 구조가 한결 나아졌다!  
최상위의 statement()함수는 이제 단 일곱 줄뿐이며, 출력한 문장을 생성하는 일만 한다.  
계산 로직은 모두 여러 개의 보조 함수로 빼냈다. 결과적으로 각 계산 과정은 물론 전체 흐름을 이해하기가 훨씬 쉬워졌다.
## 1.6 계산 단계와 포맷팅 단계 분리하기
지금까지는 프로그램의 논리적인 요소를 파악하기 쉽도록 코드의 구조를 보강하는 데 주안점을 두고 리팩터링 했다.  
`리팩터링 초기 단계에서 흔히 수행하는 일이다.`  
복잡하게 얽힌 덩어리를 잘게 쪼개는 작업은 이름을 잘 짓는 일만큼 중요하다.  
골격은 충분히 개선됐으니 이제 원하는 기능 변경, 즉 statement()의 HTML 버전응ㄹ 만드는 작업을 살펴보자!  
여러 각도에서 볼 때 확실히 처음 코드보다 작업하기 편해졌다!  
계산 코드가 모두 분리됐기 때문에 일곱 줄짜리 최상단 코드에 대응하는 HTML버전만 작성하면 된다.  
그런데 문제가 하나 있다. 분리된 계산 함수들이 텍스트 버전인 statement()안에 중첩 함수로 들어가 있다.  
이 모두를 그대로 복사해 붙이는 방식보단, 단계를 쪼개(6.11)보는 것이다.  
statement()를 두 단계로 나누는 것인데, 첫 단계에서는 statement()에 필요한 데이터를 처리하고, 다음 단계에서는 앞서 처리한 결과를 텍스트나 HTML로 표현하도록 해보는 것이다.  
다시 말해 첫 번째 단계에서는 두 번째 단계로 전달할 중간 데이터 구조를 생성하는 것이다.  
단계를 쪼개려면 먼저 두 번째 단계가 될 코드들을 함수 추출하기(6.1)로 뽑아야한다.  
이 예에서 두 번째 단계는 청구 내역을 출력하는 코드인데, 현재 statement()의  본문 전체가 여기 해당한다.
```javascript
function statement(invoice, plays) {
    return renderPlainText(invoice, plays); //본문 전체를 별도 함수로 추출
}

function renderPlainText(invoice, plays) {  //본문 전체를 별도 함수로 추출

    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;

    function totalAmount() {...}
    function totalVolumeCredits() {...}
    function usd() {...}
    function volumeCreditsFor() {...}
    function playFor() {...}
    function amountFor() {...}
}
```
다음으로 두 단계 사이의 중간 데이터 구조 역할을 할 객체를 만들어서 renderPlainText()에 인수로 전달한다.
```javascript
function statement(invoice, plays) {
    const statementData = {};
    return renderPlainText(statementData, invoice, plays); //중간 데이터 구조를 인수로 전달
}

function renderPlainText(statementData, invoice, plays) {  //중간 데이터 구조를 인수로 전달

    let result = '청구 내역 (고객명: ${invoice.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;

    function totalAmount() {...}
    function totalVolumeCredits() {...}
    function usd() {...}
    function volumeCreditsFor() {...}
    function playFor() {...}
    function amountFor() {...}
}
```
이번에는 renderPlainText()의 다른 두 인수(invoice와 plays)를 살펴본다.  
이 인수들을 통해 전달되는 데이터를 모두 방금 만든 중간 데이터 구조로 옮기면, 계산 관련 코드는 전부 statement() 함수로 모으고 renderPlainText()는 data매개 변수로 전달된 데이터만 처리하게 만들 수 있다.  
가장 먼저 고객 정보부터 중간 데이터 구조로 옮긴다.
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer; //고객 데이터를 중간 데이터로 옮긴다.
    return renderPlainText(statementData, invoice, plays);
}
function renderPlainText(data, invoice, plays) {  //고객 데이터를 중간 데이터로부터 얻는다.

    let result = '청구 내역 (고객명: ${data.customer})\n';

    for (let perf of invoice.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;

    function totalAmount() {...}
    function totalVolumeCredits() {...}
    function usd() {...}
    function volumeCreditsFor() {...}
    function playFor() {...}
    function amountFor() {...}
}
```
같은 방식으로 공연 정보까지 중간 데이터 구조로 옮기고 나면 renderPlainText()의 invoice 매개변수를 삭제해도 된다.
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer; 
    statementData.performances = invoice.performances; //공연 정보를 중간 데이터로 옮김.
    return renderPlainText(statementData, plays); //필요 없어진 인수 삭제
}
function renderPlainText(data, plays) { 

    let result = '청구 내역 (고객명: ${data.customer})\n';

    for (let perf of data.performances) {
        result += ' ${playFor(perf).name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
    }
    result += '총액: ${usd(totalAmount())}\n'; 
    result += '적립 포인트: ${totalVolumeCredits()}점\n';
    return result;

    function totalAmount() {
        let result = 0;
        for (let perf of data.performances) {
            result += amountFor(perf);
        }
        return result;
    }

    function totalVolumeCredits() {
        let result = 0;
        for (let perf of data.performances) { 
            result += result(perf);  
        }    
    }
    function usd() {...}
    function volumeCreditsFor() {...}
    function playFor() {...}
    function amountFor() {...}
}
```
이제 연극 제목도 중간 데이터 구조에서 가져오도록 한다.  
이를 위해 공연 정보 레코드에 연극 데이터를 추가해야 한다.
```javascript
function statement(invoice, plays) {
    const statementData = {};
    statementData.customer = invoice.customer; 
    statementData.performances = invoice.performances.map(enrichPerformance);
    return renderPlainText(statementData, plays); //필요 없어진 인수 삭제

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); //얕은 복사 수행
    }
}
```
여기서는 공연 객체를 복사하기만 했지만, 잠시 후 이렇게 새로 만든 레코드에 데이터를 채울 것이다.  
이때 복사를 한 이유는 함수로 건넨 데이터를 수정하기 싫어서다. 가변(mutable)데이터는 금방 상하기 때문에 저자는 데이터를 최대한 불변(immutable)처럼 취급한다.
> 자바스크립트를 처음 접한 독자는 여기 나온 **result = Object.assign({}, aPerformance)**구문이 굉장히 어색할 수 있다. 이 문장은 얕은 복사(shallow copy)를 수행한다. 이 책 저자는 함수로 만드는 방식을 선호하지만, 워낙 굳어진 표현이라서 별도 함수로 만들면 자바스크립트 프로그래머가 볼 때 오히려 어색할까봐 이렇게 작성했다.
이제 연극 정보를 담을 자리가 마련됐으니 실제로 데이터를 담기 위해 함수 옮기기 (8.1)을 적용하여 playFor() 함수를 statement()로 옮긴다.
```javascript
function statement(invoice, plays) {
    ...
    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance); 
        result.play = playFor(result);
        return result;
    }
    
    function playFor(aPerformance) { //renderPlainText()의 중접 함수였던 playFor()를 statement()로 옮김.
        return plays[aPerformance.playID];
    }
}
```
그런 다음 renderPlainText()안에서 playFor()를 호출하던 부분을 중간 데이터를 사용하도록 바꾼다.
**renderPlainText()함수**
```javascript
let result = '청구 내역 (고객명: ${data.customer})\n';

for (let perf of data.performances) {
    result += ' ${perf.play.name}: ${usd(amountFor(perf))} (${perf.audience}석)\n'; 
}
result += '총액: ${usd(totalAmount())}\n'; 
result += '적립 포인트: ${totalVolumeCredits()}점\n';
return result;

function volumeCreditsFor(aPerformance) {
    let result += Math.max(aPerformance.audience - 30,0);
    if ("comedy" === aPerformance.play.type) 
        result += Math.floor(aPerformance.audience / 5);
    return result;
}
function amountFor(aPerformance) { 
    lef result = 0; 
    switch (aPerformance.play.type) {  
        case "tragedy": //비극
            result = 40000;
            if (aPerformance.audience > 30) {
                result += 1000 * (aPerformance.audience - 30);
            }
            break;
        case "comdedy":
            result = 30000;
            if (aPerformance.audience > 20) {
                result += 10000 + 500 * (aPerformance.audience - 20);
            }
            result += 300 * aPerformance.audience;
            break;
        default:
            throw new Error('알 수 없는 장르: ${play.type}');
    }
    return result; 
}
```
이어서 amountFor()도 비슷한 방법으로 옮긴다.
**statement()함수**
```javascript
function enrichPerformance(aPerformance) {
    const result = Object.assign({}, aPerformance); 
    result.play = playFor(result);
    result.amount = amountFor(result);
    return result;
}
function amountFor(aPerformance) {...}
```
**renderPlainText()함수**
```javascript
let result = '청구 내역 (고객명: ${data.customer})\n';

for (let perf of data.performances) {
    result += ' ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n'; 
}
result += '총액: ${usd(totalAmount())}\n'; 
result += '적립 포인트: ${totalVolumeCredits()}점\n';
return result;

function totalAmount() {
    let result = 0;
    for (let perf of data.performances) {
        result += perf.amount;
    }
    return result;
}
```
다음으로 적립 포인트 계산 부분을 옮긴다.
**statement()함수**
```javascript
function enrichPerformance(aPerformance) {
    const result = Object.assign({}, aPerformance); 
    result.play = playFor(result);
    result.amount = amountFor(result);
    result.volumeCredits = volumeCredits(result);
    return result;
}

function volumeCredits(aPerformance) { ... }
```
**renderPlainText() 함수**
```javascript
function totalVolumeCredits() {
    let result = 0;
    for (let perf of data.performances) {
        result += perf.volumeCredits;
    }
    return result;
}
```
마지막으로 총합을 구하는 부분을 옮긴다.
**statement()함수**
```javascript
const statementData = {};
statementData.customer = invoice.customer;
statementData.performances = invoice.performances.map(enrichPerformance);
statementData.totalAmount = totalAmount(statementData);
statementData.totalVolumeCredits = totalVolumeCredits(statementData);

return renderPlainText(statementData, plasy);

function totalAmount(data) {...}
function totalVolumeCredits(data) {...}
```
**renderPlainText() 함수**
```javascript
let result = '청구 내역 (고객명: ${data.customer}\n)';
for (let perf of data.performances) {
    result += ' ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n';
    result += '총액: ${usd(data.totalAmount)}\n';
    result += '적립 포인트 : ${data.totalVolumeCredits}점\n';
    return result;
}
```
이때 총합을 구하는 두 함수 totalAmount()와 totalVolumeCredits()의 본문에서 statementData변수를 사용할 수도 있지만, 이 책 저자는 명확히 매개변수로 전달하는 방식을 선호하여 이렇게 수정했다.  
이렇게 옮기고 나니 가볍게 반복문을 파이프라인으로 바꾸기(8.8)을 적용하고 싶어진다.
**renderPlainText()함수**
```javascript
function totalAmount(data) {
    return data.performances  //for 반복문을 파이프 라인으로 변경
        .reduce((total, p) => total + p.amount, 0);
}
function totalVolumeCredits(data) {
    return data.performances  //for 반복문을 파이프 라인으로 변경
        .reduce((total, p) => total + p.volumeCredits, 0);    
}
```
이제 첫 단계인 'statement()에 필요한 데이터 처리'에 해당하는 코드를 모두 별도 함수로 빼낸다.
```javascript
function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}

function createStatementData(invoice, plays) { //중간 데이터 생성을 전담.
    const statementData = {};
    statementData.customer = invoice.customer;
    statementData.performances = invoice.performances.map(enrichPerformance);
    statementData.totalAmount = totalAmount(statementData);
    statementData.totalVolumeCredits = totalVolumeCredits(statementData);
    return statementData;
}
```
두 단계가 명확히 분리됐으니 각 코드를 별도 파일에 저장한다.  
**statement.js**
```javascript
import createStatementData from './createStatementData.js';
```
**createStatementData.js**
```javascript
export default function createStatementData(invoice, plays) { //중간 데이터 생성을 전담.
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(statementData);
    result.totalVolumeCredits = totalVolumeCredits(statementData);
    return result;

    function enrichPerformance(aPerformance) {...}
    function playFor(aPerformance) {...}
    function amountFor(aPerformance) {...}
    function volumeCreditsFor(aPerformance) {...}
    function totalAmount(aPerformance) {...}
    function totalVolumeCredits(aPerformance) {...}

}
```
마지막으로 컴파일-테스트-커밋하고 나면 드디어 HTML버전을 작성할 준비가 끝난다.
**statement.js**
```javascript
function htmlStatement(invoice, plays) {
    return renderHtml(createStatementData(invoice, plays));
}

function renderHtml(data) {
    let result = '<h1>청구 내역 (고객명: ${data.customer})</h1>\n';
    result += "<table>\n";
    result += "<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>";
    for(let perf of data.performances) {
        result += ' <tr><td>${perf.play.name}</td><td>(${perf.audience}석)</td>";
        result += '<td>${usd(perf.amount)}</td></tr>\n';
    }
    result += "</table>\n";
    result += "<p>총액: <em>${usd(data.totalAmount)}</em></p>\n";
    result += "<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>\n';
    return result;
}
function usd(aNumber) {...}
```
usd()를 renderHtml()에서도 사용할 수 있도록 최상위로 옮겼다.
# 7. 중간 점검: 두파일(과 두 단계)로 분리됨.
잠시 쉬면서 코드의 상태를 점검해본다. 현재 코드는 두 개의 파일로 구성된다.
**statement.js**
```javascript
import createStatementData from './createStatementData.js';

function statement(invoice, plays) {
    return renderPlainText(createStatementData(invoice, plays));
}

function renderPlainText(data) {
    let result = '청구 내역 (고객명: for ${data.customer})\n';
    for (let perf of data.performances) {
        result += ' ${perf.play.name}: ${usd(perf.amount)} (${perf.audience}석)\n';
    }
    result += '총액: ${usd(data.totalAmount)}\n';
    result += '적립 포인트: ${data.totalVolumeCredits}점\n';
    return result;
}

function htmlStatement(invoice, plays) {
    return renderHtml(createStatementData(invoice, plays));
}

function renderHtml(data) {
    let result = '<h1>청구 내역 (고객명: ${data.customer})</h1>\n';
    result += "<table>\n";
    result += "<tr><th>연극</th><th>좌석 수</th><th>금액</th></tr>";
    for(let perf of data.performances) {
        result += ' <tr><td>${perf.play.name}</td><td>(${perf.audience}석)</td>";
        result += '<td>${usd(perf.amount)}</td></tr>\n';
    }
    result += "</table>\n";
    result += "<p>총액: <em>${usd(data.totalAmount)}</em></p>\n";
    result += "<p>적립 포인트: <em>${data.totalVolumeCredits}</em>점</p>\n';
    return result;
}
function usd(aNumber) {
    return new Intl.NumberFormat("en-US",
                        { style: "currency", currency: "USD",
                          minimumFractionDigits: 2 }).format(aNumber/100);
}
```
**createStatementData.js**
```javascript
export default function createStatementData(invoice, plays) {
    const result = {};
    result.customer = invoice.customer;
    result.performances = invoice.performances.map(enrichPerformance);
    result.totalAmount = totalAmount(statementData);
    result.totalVolumeCredits = totalVolumeCredits(statementData);
    return result;

    function enrichPerformance(aPerformance) {
        const result = Object.assign({}, aPerformance);
        result.play = playFor(result);
        result.amount = amountFor(result);
        result.volumeCredits = volumeCreditsFor(result);
        return result;
    }
    function playFor(aPerformance) {
        return plays[aPerformance.playID];
    }
    function amountFor(aPerformance) {
        let result = 0;
        switch (aPerformance.play.type) {
            case "tragedy": //비극
                result = 40000;
                if (aPerformance.audience > 30) {
                    result += 1000 * (aPerformance.audience - 30);
                }
                break;
            case "comedy": //희극
                result = 30000;
                if (aPerformance.audience > 20) {
                    result += 10000 * (aPerformance.audience - 20);
                }
                result += 300 * aPerformance.audience;
                break;
            default:
                throw new Error('알 수 없는 장르: ${aPerformance.play.type}');
        }
        return result;
    }
    function volumeCreditsFor(aPerformance) {
        let result = 0;
        result += Math.max(aPerformance.audience - 30, 0);
        if ("comedy" === aPerformance.play.type) result += Math.floor(aPerformance.audience / 5);
        return result;
    }
    function totalAmount(data) {
        return data.performances
            .reduce((total, p) => total + p.amount, 0);
    }
    function totalVolumeCredits(data) {
        return data.performances
            .reduce((total, p) => total + p.amount, 0);        
    }

}
```
처음 44줄짜리 코드가 htmlStatement()를 뺴고도 70줄이나 된다.  
늘어난 주된 원인은 함수로 추출하면서 함수 본문을 열고 닫는 괄호가 덧붙었기 떄문이다.  
하지만, 추가된 코드 덕분에 전체 로직을 구성하는 요소 각각이 더 뚜렷이 부각되고, 계산하는 부분과 출력 형식을 다루는 부분이 분리됐다.  
이렇게 모듈화하면 각 부분이 하는 일과 그 부분들이 맞물려 돌아가는 과정을 파악하기 쉬워진다.  
간결함이 지혜의 정수일지 몰라도, 프로그래밍에서만큼은 명료함이 진화할 수 있는 소프트웨어의 정수다.  
모듈화한 덕분에 계산 코드를 중복하지 않고도 HTML버전을 만들 수 있었다.
> 캠핑자들에게 "도착했을 때보다 깔끔하게 정돈하고 떠난다"는 규칙이 있다. 프로그래밍도 마찬가지다. 항시 코드베이스를 작업 시작 전보다 건강하게 만들어놓고 떠나야한다.


> 좋은 코드를 가늠하는 확실한 방법은 얼마나 수정하기 쉬운가다.