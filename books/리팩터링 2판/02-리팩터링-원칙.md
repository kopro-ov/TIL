| 내용 | 최초 작성일 | 참고 |
|---|:---:|---:|
| 리팩터링 원칙 | 2021-08-06 | 리팩터링 2판 |
# 리팩터링 정의
> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.
> 리팩터링: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.
두 버전의 용어를 한 문장에 담으면 '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 것 같다.'  
지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 '리팩터링'이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.  
리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.
> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다."라고 하면 십중팔구 리팩터링한 것이다.
리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다. 그렇다고 완전히 똑같다는 말은 아니다.  
예를 들면 함수 추출하기를 거치면 콜스택이 달라져서 성능이 변할 수 있다. 그렇다고 해도 사용자 관점에서는 달라지는 점이 없어야한다.  
특히 함수 선언 바꾸기나 함수 옮기기 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다.  
리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.  
단지 목적이 다를뿐이다. 리팩터링의 목적은 코드르 ㄹ이해하고 수정하기 쉽게 만드는 것이다.  
프로그램 성능은 좋아질 수도 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다.
## 두개의 모자
책 저자는 소프트웨어를 개발할 때 목적이
1. 기능 추가냐
2. 리팩터링이냐
를 명확히 구분해 작업한다고 한다.  
켄트 벡은 이를 두 개의 모자에 비유했다.  
기능을 추가할 때는 '기능 추가'모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.  
반면 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 테스트도 새로 만들지 않고, 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.  
새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔 쓰고 리팩터링한다.  
코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다. 추가한 기능이 제대로 작동하는지까지 확인햇다면 작성한 코드를 살펴본다.  
코드가 이해하기 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩터링한다.
## 리팩터링 하는 이유
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다.  
하지만 코드를 건강한 상태로 유지하는 데 도와준다.  
리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.
1. 리팩터링하면 소프트웨어 설계가 좋아진다.
리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다.  
아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.  
코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고 설계가 부패되는 속도는 더욱 빨라진다.  
반면 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다. 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.  
그런데 내 소스 코드를 컴퓨터만 사용하는 게 아니다. 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다.  
프로그래밍에게서는 사람이 가장 중요하지만 소홀하기 쉽다. 코드를 컴파일하는 데 시간이 살짝 더 걸린다고 누가 뭐라 하겠는가?  
하지만 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸린다면 사정이 달라진다.  
코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선해야한다.
3. 리팩터링하면 버그를 쉽게 찾을 수 있다.
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.  
리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.  
프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도로 명확해진다.  
켄트 벡 "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."  
리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.
4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.
리팩터링하면 코드 개발 속도를 높일 수 있다.  
리팩터링에 대해 설명하면 품질을 높일 수 있다는 점에 대부분은 쉽게 수긍한다. 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 대부분 쉽게 수긍한다. 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직뎔된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수 있다.  
한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다는 말을 많이 한다.  
새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 는다는 것이다. 게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다. 코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 거의 고대 유적 발굴만큼 어려워진다.  
이러한 부담이 기능 추가 속도를 계속 떨어트리면서, 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다.  
하지만 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.  
모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.  
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.  
내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.  
이 책 저나는 이 효과를 설계 지구력 가설이라고 한다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.  
리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.  
처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.
## 언제 리팩터링해야 할까?
돈 로버츠가 제시한 3의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면 (중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.
야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)'로 기억하자!
## 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기.
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.  
이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.  
**함수 매개변수화하기!**  
버그를 자을 때도 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.  
또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.  
이처럼 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있다. 
## 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기.
코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.  
그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다.  
워드 커닝햄이 말하길 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.  
어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 한다. 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다.  
랄프 존슨은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기에 비유한다. 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라도 도달하지 못했을 더 깊은 수준까지 이해하게 된다. 이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없다.
## 쓰레기 줍기 리팩터링
코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다. 그렇다고 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하도록 내버려두는 것도 좋지 않다.  
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.  
이것을 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.  
캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.  
코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.  
리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.  
그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.
## 계획된 리팩터링과 수시로 하는 리팩터링
앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다.  
저자는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도함께 한다.  
프로그래밍 과정에 자연스럽게 녹인 것이다. 기능을 추가할 때든 버그를 잡을 때든, 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에 도움을 준다.  
간과하기 쉽지만 굉장히 중요한 점이다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.  
마치 프로그래밍할 때 if문 작성 시간을 따로 구분하지 않는 것과 같다.  
> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
매개변수화하거나 개별 함수로 나누는 기준을 정한다. 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다.  
이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링 하기 더 쉽다.
> 무언가 수정할 때는 먼저 수정하기 쉽게 정돈하고, 그런 다음 쉽게 수정하다 -켄트 벡-
그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.  
이때 리팩터링에 투자한 일주일의 효과를 다음 몇 달 동안 누릴 수 있다. 한편, 정기적으로 리팩터링하더라도 어떤 문제는 팀원 여럿이 달려들어야 할 정도로 곪아갈 수도 있다. 하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야한다.  
리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야한다.  
버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다.  
이렇게 할 때의 큰 장점은 두 가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는 것이다.  
하지만 이 책의 저자는 이 견해에 완전히 동의하지 않는다고 한다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.  
리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 여러분의 팀에 적합한 방식을 시험을 통해 찾아내야 한다.
## 오래 걸리는 리팩터링
리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간 정도다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.  
라이브러리를 새 것으로 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.  
또는 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수 도 있다.  
누구든지 리팩터링 해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.  
리팩터링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 작동한다.  
라이브러리를 교체할 때는 기존 것과 새 것 모두를 포옹하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. (이 전략을 추상화로 갈아타기라 한다.)
## 코드 리뷰에 리팩터링 활용하기
코드 리뷰를 정기적으로 수행하는 조직도 있다.  
그렇지 않은 조직이라면 해보면 유익할 것이다.  
코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.  
대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움이 된다.  
깔끔한 코드를 작성하는 데에도 굉장히 중요하다.  
코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다. 일주일이면 좋은 아이디어를 상당히 많이 수집할 수 있을 것이다.  
이처럼 서로의 기여가 일을 더욱 편하게 만들어주므로 저자는 기회가 닿는 대로 코드 리뷰를 한다.  
리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다. 리팩터링을 활용하기 전에는 코드를 읽고 그럭저럭 이해한 뒤 몇 가지 개선 사항을 제시했다.  
지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지 살펴본다. 쉽다면 실제로 리팩터링한다.  
코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다. 흔히 쓰는 풀요청 모델(코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로 이왕이면 참석자가 참석하는 방식이 좋다. 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것이다. 이렇게 하면 자연스럽게 짝 프로그래밍이 된다.
## 관리자에게는 뭐라고 말해야 할까?
"관리자에게 리팩터링에 대해 어떻게 말해야 하나요?" 관리자와 고객이 '리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있다.  
리팩터링만을 위한 일정을 몇 주씩 잡는 개발팀을 보면 오해는 더욱 커진다.  
설상가상으로 실제로는 리팩터링이 아닌, 어설픈 재구성 작업을 하면서 코드베이스를 오히려 망가뜨리는 모습을 보면 불신이 증폭된다.  
소프트웨어 개발자는 프로다. 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다.  
리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다. 새 함수를 추가하려는데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다. 버그를 수정하려면 현재 소프트웨어의 작동 방식을 이해해야한다.  
일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그리고 구체적인 방법은 개발자가 판단해야 한다. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.
## 리팩터링하지 말아야 할 때
지금까지의 이야기가 무조건 리팩터링을 권장한다고 들릴 수 있는데, 리팩터링하면 안 되는 상황도 있다.  
저자는 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API다루둣 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.  
내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.  
리팩터링하는 것보다 처움부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.  
사실 이런 결정을 내리기는 쉽지 않다. 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을떄도 많기 떄문이다.  
리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야한다.

