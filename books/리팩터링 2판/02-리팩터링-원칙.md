| 내용 | 최초 작성일 | 참고 |
|---|:---:|---:|
| 리팩터링 원칙 | 2021-08-06 | 리팩터링 2판 |
# 리팩터링 정의
> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법.

> 리팩터링: [동사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러 가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

두 버전의 용어를 한 문장에 담으면 '앞으로 몇 시간은 리팩터링할 것 같은데 그 사이 적용하는 리팩터링은 수십 가지나 될 것 같다.'  
지금껏 수많은 사람이 코드를 정리하는 작업을 모조리 '리팩터링'이라고 표현하고 있는데, 앞에서 제시한 정의를 따르면 특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다.  
리팩터링은 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다.  
리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다.
> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다."라고 하면 십중팔구 리팩터링한 것이다.

리팩터링하기 전과 후의 코드가 똑같이 동작해야 한다. 그렇다고 완전히 똑같다는 말은 아니다.  
예를 들면 함수 추출하기를 거치면 콜스택이 달라져서 성능이 변할 수 있다. 그렇다고 해도 사용자 관점에서는 달라지는 점이 없어야한다.  
특히 함수 선언 바꾸기나 함수 옮기기 같은 리팩터링을 하면 모듈의 인터페이스가 바뀔 때가 많다.  
리팩터링은 성능 최적화와 비슷하다. 둘 다 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다.  
단지 목적이 다를뿐이다. 리팩터링의 목적은 코드르 ㄹ이해하고 수정하기 쉽게 만드는 것이다.  
프로그램 성능은 좋아질 수도 나빠질 수도 있다. 반면 성능 최적화는 오로지 속도 개선에만 신경쓴다. 그래서 목표 성능에 반드시 도달해야 한다면 코드는 다루기에 더 어렵게 바뀔 수도 있음을 각오해야 한다.
## 두개의 모자
책 저자는 소프트웨어를 개발할 때 목적이
1. 기능 추가냐
2. 리팩터링이냐
를 명확히 구분해 작업한다고 한다.  
켄트 벡은 이를 두 개의 모자에 비유했다.  
기능을 추가할 때는 '기능 추가'모자를 쓴 다음 기존 코드는 절대 건드리지 않고 새 기능을 추가하기만 한다. 진척도는 테스트를 추가해서 통과하는지 확인하는 방식으로 측정한다.  
반면 리팩터링할 때는 '리팩터링' 모자를 쓴 다음 기능 추가는 절대 하지 않기로 다짐한 뒤 오로지 코드 재구성에만 전념한다. 테스트도 새로 만들지 않고, 부득이 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다.  
새 기능을 추가하다 보면 코드 구조를 바꿔야 작업하기 훨씬 쉽겠다는 생각이 들기도 하는데, 그러면 잠시 모자를 바꿔 쓰고 리팩터링한다.  
코드 구조가 어느 정도 개선되면 다시 모자를 바꿔 쓰고 기능 추가를 이어간다. 추가한 기능이 제대로 작동하는지까지 확인햇다면 작성한 코드를 살펴본다.  
코드가 이해하기 어렵게 짜였다면 다시 모자를 바꿔 쓰고 리팩터링한다.
## 리팩터링 하는 이유
리팩터링이 소프트웨어의 모든 문제점을 해결하는 만병통치약은 절대 아니다.  
하지만 코드를 건강한 상태로 유지하는 데 도와준다.  
리팩터링은 다양한 용도로 활용할 수 있고, 또 반드시 그래야 하는 도구다.
1. 리팩터링하면 소프트웨어 설계가 좋아진다.
리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다.  
아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다.  
코드만으로 설계를 파악하기 어려워질수록 설계를 유지하기 어려워지고 설계가 부패되는 속도는 더욱 빨라진다.  
반면 규칙적인 리팩터링은 코드의 구조를 지탱해준다.
2. 리팩터링하면 소프트웨어를 이해하기 쉬워진다.
프로그래밍은 여러 면에서 마치 컴퓨터와 대화하는 것과 같다. 컴퓨터에게 시키려는 일과 이를 표현한 코드의 차이를 최대한 줄여야한다. 프로그래밍은 결국 내가 원하는 바를 정확히 표현하는 일이다.  
그런데 내 소스 코드를 컴퓨터만 사용하는 게 아니다. 몇 달이 지나 누군가 내 코드를 수정하고자 읽게 될 수 있다.  
프로그래밍에게서는 사람이 가장 중요하지만 소홀하기 쉽다. 코드를 컴파일하는 데 시간이 살짝 더 걸린다고 누가 뭐라 하겠는가?  
하지만 다른 프로그래머가 내 코드를 제대로 이해했다면 한 시간에 끝낼 수정을 일주일이나 걸린다면 사정이 달라진다.  
코드의 목적이 더 잘 드러나게, 다시 말해 내 의도를 더 명확하게 전달하도록 개선해야한다.
3. 리팩터링하면 버그를 쉽게 찾을 수 있다.
코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다.  
리팩터링하면 코드가 하는 일을 깊이 파악하게 되면서 새로 깨달은 것을 곧바로 코드에 반영하게 된다.  
프로그램의 구조를 명확하게 다듬으면 그냥 '이럴 것이다'라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도로 명확해진다.  
켄트 벡 "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."  
리팩터링은 견고한 코드를 작성하는 데 무척 효과적이다.
4. 리팩터링하면 프로그래밍 속도를 높일 수 있다.
리팩터링하면 코드 개발 속도를 높일 수 있다.  
리팩터링에 대해 설명하면 품질을 높일 수 있다는 점에 대부분은 쉽게 수긍한다. 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 대부분 쉽게 수긍한다. 내부 설계와 가독성이 개선되고 버그가 줄어든다는 점은 모두 품질 향상에 직뎔된다. 하지만 리팩터링하는 데 시간이 드니 전체 개발 속도는 떨어질까봐 걱정할 수 있다.  
한 시스템을 오래 개발 중인 개발자들과 얘기하다 보면 초기에는 진척이 빨랐지만 현재는 새 기능을 하나 추가하는 데 훨씬 오래 걸린다는 말을 많이 한다.  
새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 는다는 것이다. 게다가 기능을 추가하고 나면 버그가 발생하는 일이 잦고, 이를 해결하는 시간은 한층 더 걸린다. 코드베이스는 패치에 패치가 덧붙여지면서 프로그램의 동작을 파악하기가 거의 고대 유적 발굴만큼 어려워진다.  
이러한 부담이 기능 추가 속도를 계속 떨어트리면서, 차라리 처음부터 새로 개발하는 편이 낫겠다고 생각하는 지경에 이른다.  
하지만 내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.  
모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다.  
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다.  
내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다.  
이 책 저나는 이 효과를 설계 지구력 가설이라고 한다. 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.  
리팩터링하면 기존 코드의 설계를 얼마든지 개선할 수 있으므로, 설령 프로그램 요구사항이 바뀌더라도 설계를 지속해서 개선할 수 있다.  
처음부터 좋은 설계를 마련하기란 매우 어렵다. 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다.
## 언제 리팩터링해야 할까?
돈 로버츠가 제시한 3의 법칙
1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면 (중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.
야구를 좋아하는 사람은 '스트라이크 세 번이면 리팩터링하라(삼진 리팩터링)'로 기억하자!
## 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기.
리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다.  
이 시점에 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다.  
**함수 매개변수화하기!**  
버그를 자을 때도 오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다.  
또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다.  
이처럼 준비를 위한 리팩터링으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수 있다. 
## 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기.
코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다.  
그 코드를 작성한 사람은 자신일 수도 있고 다른 사람일 수도 있다. 코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다. 조건부 로직의 구조가 이상하지 않은지 살펴보기도 하고, 함수 이름을 잘못 정해서 실제로 하는 일을 파악하는 데 시간이 오래 걸리지는 않는지도 살펴본다.  
워드 커닝햄이 말하길 리팩터링하면 머리로 이해한 것을 코드에 옮겨 담을 수 있다. 그런 다음 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다. 내가 이해한 것을 코드에 반영해두면 더 오래 보존할 수 있을 뿐만 아니라 동료들도 알 수 있다.  
어떤 역할을 하는지 이해된 변수는 적절한 이름으로 바꿔주고, 긴 함수를 잘게 나누기도 한다. 그러면 코드가 깔끔하게 정리되어 전에는 보이지 않던 설계가 눈에 들어오기 시작한다.  
랄프 존슨은 이런 초기 단계의 리팩터링을 밖을 잘 내다보기 위한 창문 닦기에 비유한다. 코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라도 도달하지 못했을 더 깊은 수준까지 이해하게 된다. 이해를 위한 리팩터링을 의미 없이 코드를 만지작거리는 것이라고 무시하는 이들은 복잡한 코드 아래 숨어 있는 다양한 기회를 결코 발견할 수 없다.
## 쓰레기 줍기 리팩터링
코드를 파악하던 중에 일을 비효율적으로 처리하는 모습을 발견할 때가 있다. 로직이 쓸데없이 복잡하거나, 매개변수화한 함수 하나면 될 일을 거의 똑같은 함수 여러 개로 작성해놨을 수 있다. 이때 약간 절충을 해야 한다. 원래 하려던 작업과 관련 없는 일에 너무 많은 시간을 빼앗기긴 싫을 것이다. 그렇다고 쓰레기가 나뒹굴게 방치해서 나중에 일을 방해하도록 내버려두는 것도 좋지 않다.  
간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 나서 처리한다.  
이것을 이해를 위한 리팩터링의 변형인 쓰레기 줍기 리팩터링이다.  
캠핑 규칙이 제안하듯, 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.  
코드를 훑어볼 때마다 조금씩 개선하다 보면 결국 문제가 해결될 것이다.  
리팩터링의 멋진 점은 각각의 작은 단계가 코드를 깨뜨리지 않는다는 사실이다.  
그래서 작업을 잘게 나누면 몇 달에 걸쳐 진행하더라도 그 사이 한 순간도 코드가 깨지지 않기도 한다.
## 계획된 리팩터링과 수시로 하는 리팩터링
앞에서 본 준비를 위한 리팩터링, 이해를 위한 리팩터링, 쓰레기 줍기 리팩터링은 모두 기회가 될 때만 진행한다.  
저자는 개발에 들어가기 전에 리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도함께 한다.  
프로그래밍 과정에 자연스럽게 녹인 것이다. 기능을 추가할 때든 버그를 잡을 때든, 리팩터링은 눈앞의 문제뿐 아니라 앞으로 할 작업에 도움을 준다.  
간과하기 쉽지만 굉장히 중요한 점이다. 리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다.  
마치 프로그래밍할 때 if문 작성 시간을 따로 구분하지 않는 것과 같다.  
> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.
매개변수화하거나 개별 함수로 나누는 기준을 정한다. 어제는 적합했던 기준이 오늘 하는 다른 작업에는 맞지 않을 수 있다.  
이렇게 상황이 변해 기준을 변경해야 할 때 코드가 이미 깔끔하다면 리팩터링 하기 더 쉽다.

> 무언가 수정할 때는 먼저 수정하기 쉽게 정돈하고, 그런 다음 쉽게 수정하다 -켄트 벡-

그동안 리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다.  
이때 리팩터링에 투자한 일주일의 효과를 다음 몇 달 동안 누릴 수 있다. 한편, 정기적으로 리팩터링하더라도 어떤 문제는 팀원 여럿이 달려들어야 할 정도로 곪아갈 수도 있다. 하지만 이런 이유로 계획된 리팩터링을 하게 되는 일은 최소한으로 줄여야한다.  
리팩터링 작업 대부분은 드러나지 않게, 기회가 될 때마다 해야한다.  
버전 관리 시스템에서 리팩터링 커밋과 기능 추가 커밋을 분리해야 한다는 조언을 들은 적이 있다.  
이렇게 할 때의 큰 장점은 두 가지 활동을 구분해서 별개로 검토하고 승인할 수 있다는 것이다.  
하지만 이 책의 저자는 이 견해에 완전히 동의하지 않는다고 한다. 리팩터링은 기능 추가와 밀접하게 엮인 경우가 너무나 많기 때문에 굳이 나누는 것은 시간 낭비일 수 있다. 또한 해당 리팩터링을 하게 된 맥락 정보가 사라져서 왜 그렇게 수정했는지 이해하기 어려워진다.  
리팩터링 커밋을 분리한다고 해서 무조건 좋은 것은 아님을 명심하고, 여러분의 팀에 적합한 방식을 시험을 통해 찾아내야 한다.
## 오래 걸리는 리팩터링
리팩터링은 대부분 몇 분 안에 끝난다. 길어야 몇 시간 정도다. 하지만 팀 전체가 달려들어도 몇 주는 걸리는 대규모 리팩터링도 있다.  
라이브러리를 새 것으로 교체하는 작업일 수도 있고, 일부 코드를 다른 팀과 공유하기 위해 컴포넌트로 빼내는 작업일 수도 있다.  
또는 그동안 작업하면서 쌓여온 골치 아픈 의존성을 정리하는 작업일 수 도 있다.  
누구든지 리팩터링 해야할 코드와 관련한 작업을 하게 될 때마다 원하는 방향으로 조금씩 개선하는 식이다.  
리팩터링이 코드를 깨트리지 않는다는 장점을 활용하는 것이다. 일부를 변경해도 모든 기능이 항상 올바르게 작동한다.  
라이브러리를 교체할 때는 기존 것과 새 것 모두를 포옹하는 추상 인터페이스부터 마련한다. 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 교체할 수 있다. (이 전략을 추상화로 갈아타기라 한다.)
## 코드 리뷰에 리팩터링 활용하기
코드 리뷰를 정기적으로 수행하는 조직도 있다.  
그렇지 않은 조직이라면 해보면 유익할 것이다.  
코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다. 경험이 더 많은 개발자의 노하우를 더 적은 개발자에게 전수할 수 있다.  
대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해하는 데도 도움이 된다.  
깔끔한 코드를 작성하는 데에도 굉장히 중요하다.  
코드 리뷰를 하면 다른 사람의 아이디어를 얻을 수 있다는 장점도 있다. 일주일이면 좋은 아이디어를 상당히 많이 수집할 수 있을 것이다.  
이처럼 서로의 기여가 일을 더욱 편하게 만들어주므로 저자는 기회가 닿는 대로 코드 리뷰를 한다.  
리팩터링은 다른 이의 코드를 리뷰하는 데도 도움이 된다. 리팩터링을 활용하기 전에는 코드를 읽고 그럭저럭 이해한 뒤 몇 가지 개선 사항을 제시했다.  
지금은 새로운 아이디어가 떠오르면 리팩터링하여 쉽게 구현해넣을 수 있는지 살펴본다. 쉽다면 실제로 리팩터링한다.  
코드 리뷰에 리팩터링을 접목하는 구체적인 방법은 리뷰의 성격에 따라 다르다. 흔히 쓰는 풀요청 모델(코드 작성자 없이 검토하는 방식)에서는 그리 효과적이지 않다. 코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로 이왕이면 참석자가 참석하는 방식이 좋다. 작성자와 나란히 앉아서 코드를 훑어가면서 리팩터링 하는 것이다. 이렇게 하면 자연스럽게 짝 프로그래밍이 된다.
## 관리자에게는 뭐라고 말해야 할까?
"관리자에게 리팩터링에 대해 어떻게 말해야 하나요?" 관리자와 고객이 '리팩터링은 누적된 오류를 잡는 일이거나, 혹은 가치 있는 기능을 만들어내지 못하는 작업'이라고 오해하여 리팩터링이 금기어가 돼버린 조직도 있다.  
리팩터링만을 위한 일정을 몇 주씩 잡는 개발팀을 보면 오해는 더욱 커진다.  
설상가상으로 실제로는 리팩터링이 아닌, 어설픈 재구성 작업을 하면서 코드베이스를 오히려 망가뜨리는 모습을 보면 불신이 증폭된다.  
소프트웨어 개발자는 프로다. 프로 개발자의 역할은 효과적인 소프트웨어를 최대한 빨리 만드는 것이다.  
리팩터링하면 소프트웨어를 빠르게 만드는 데 아주 효과적이다. 새 함수를 추가하려는데 현재 설계가 적합하지 않다면 먼저 리팩터링하고 나서 함수를 추가하는 편이 빠르다. 버그를 수정하려면 현재 소프트웨어의 작동 방식을 이해해야한다.  
일정을 최우선으로 여기는 관리자는 최대한 빨리 끝내는 방향으로 진행하기를 원한다. 그리고 구체적인 방법은 개발자가 판단해야 한다. 프로 개발자에게 주어진 임무는 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다. 그래서 리팩터링부터 한다.
## 리팩터링하지 말아야 할 때
지금까지의 이야기가 무조건 리팩터링을 권장한다고 들릴 수 있는데, 리팩터링하면 안 되는 상황도 있다.  
저자는 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다. 외부 API다루둣 호출해서 쓰는 코드라면 지저분해도 그냥 둔다.  
내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다.  
리팩터링하는 것보다 처움부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다.  
사실 이런 결정을 내리기는 쉽지 않다. 직접 리팩터링해보기 전에는 어느 쪽이 쉬운지 확실히 알 수 없을떄도 많기 떄문이다.  
리팩터링할지 새로 작성할지를 잘 결정하려면 뛰어난 판단력과 경험이 뒷받침돼야한다.
# 리팩터링 시 고려할 문제
특정한 기술, 도구, 아키텍처 등을 내세울 때마다 항상 문제점을 찾는다.  
살다 보면 항상 화창한 날만 있는 것은 아니다. 그래서 무언가를 언제 어디에 적용할지 판단하려면 손익을 제ㅐㄷ로 이해야한다.
## 새 기능 개발 속도 저하
리팩터링의 궁극적인 목적은 개발 속도를 높이는 데 있다. 하지만 리팩터링으로 인해 진행이 느려진다고 생각하는 사람이 여전히 많다.  
아마도 이 점이 실전에서 리팩터링을 제대로 적용하는 데 가장 큰 걸림돌인 것 같다.
> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다.
그렇다라도 상황에 맞게 조율해야 한다.  
개발 속도 저하를 이유로 리팩터링을 금하는 비생산적인 문화를 관리자 탓으로 돌리는 사람이 많지만, 저자는 오히려 개발자 스스로가 그렇게 생각하는 경우도 많이 봤다고 한다. 심지어 관리자가 리팩터링에 호의적임에도 리팩터링하면 안 되는 줄 아는 사람도 있다.  
개발팀을 이끌고 있다면 코드베이스가 더 건강해지는 것을 추구한다는 사실을 팀원들에게 명확히 밝혀야 한다.  
리더는 리팩터링 경험이 부족한 이들이 이런 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다.  
하지만 저자는 사람들이 빠지기 쉬운 가장 위험한 오류는 리팩터링을 '클린 코드'나 '바람직한 엔지니어 습관'처럼 도덕적인 이유로 정당화하는 것이다.  
**리팩터링의 본질은 코드 베이스를 예쁘게 꾸미는 데 있지 않다. 오로지 경제적인 이유로 하는 것이다.**  
리팩터링은 개발 기간을 단축하고자 하는 것이다. 기능 추가 시간을 줄이고, 버그 수정 시간을 줄여준다. 스스로 그렇게 인식하는 데 그치지 말고 다른 사람과 대화할 때도 이 점을 명심해야 한다.  
리팩터링하도록 이끄는 동력은 어디까지나 경제적인 효과에 있다. 이를 명확히 이해하는 개발자, 관리자, 고객이 많아질수록 앞에서 본 소프트웨어 개발 진행 그래프에서 '좋은 설계'곡선을 더 많이 볼 수 있다.
## 코드 소유권
리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다.  
함수 이름을 바꾸고 싶고 그 함수를 호출하는 곳을 모두 찾을 수 있다면 간단히 **함수 선언 바꾸기(6.5)**로 선언 자체와 호출하는 곳 모두를 한 번에 바꿀 수 있다. 하지만 함수를 호출하는 코드의 소유자가 다른 팀이라서 나에게는 쓰기 권한이 없을 수 없다. 또는 바꾸려는 함수가 고객에게 API로 제공하는 것이라면 등등.. 이런 함수는 인터페이스를 누가 선언했는지에 관계없이 클라이언트가 사용하는 '공개된 인터페이스'에 속한다.  
그렇다고 리팩터링을 할 수 없는 건아니다. 여전히 훌륭하게 개선할 수 있지만 제약이 따를 뿐이다. 예컨대 함수 이름을 변경할 때는 **함수 이름 바꾸기(6.5)**를 적용하는 한편, 기존 함수도 그대로 유지하되 함수 본문에서 새 함수를 호출하도록 수정한다. 인터페이스는 복잡해지지만 클라이언트에 영향을 주지 않기 위해서는 어쩔 수 없다.  
기존 인터페이스를 폐기 대상으로 지정하고 시간이 흐른 뒤에 삭제할 수 있지만 때로는 영원히 남겨야한다.  
이처럼 복잡해지기 때문에 책 저자는 코드 소유권을 작은 단위로 나눠 엄격히 관리하는 데 반대하는 입장이다.  
어떤 조직은 모든 코드의 소유권을 한 사람에게 맡기도 그 사람만 코드를 수정할 수 있게 한다. 또 세 명의 팀원 각자가 상대방에게 공개 인터페이스를 제공하는 사례도 봤다.  
이렇게 하면 코드베이스에서 곧바로 수정하면 훨씬 간단한 일을 계속해서 인터페이스를 관리하느라 시달리는 결과를 초래한다.  
저자가 선호나는 방식은 코드의 소유권을 팀에 두는 것이다. 그래서 팀원이라면 누구나 팀이 소유한 코드를 수정할 수 있게 한다. 설사 다른 사람이 작성했더라도 말이다.  
프로그래머마다 각자 책임지는 영역이 있을 수 있다. 이 말은 자식이 맡은 영역의 변경 사항을 관리하라는 뜻이지, 다른 사람이 수정하지 못하게 막으라는 뜻이 아니다.  
## 브랜치
현재 흔히 볼 수 있는 팀 단위 작업 방식은 버전 관리 시스템을 사용하여 팀원마다 코드베이스의 브랜치를 하나씩 맡아서 작업하다가, 결과물이 어느 정도 쌓이면 마스터 브랜치(트렁크trunk)에 통합해서 다른 팀원과 공유하는 것이다.  
그런데 이렇게 하면 어떤 기능 전체를 한 브랜츠에만 구현해놓고, 프로덕션 버전으로 릴리스할 때가 돼서야 마스터에 통합하는 경우가 많다. 이 방식을 선호하는 이들은 작업이 끝나지 않은 코드가 마스터에 섞이지 않고, 기능이 추가될 때마다 버전을 명확히 나눌 수 있고, 기능에 문제가 생기면 이전 상태로 쉽게 되돌릴 수 있어서 좋다고 한다.  
하지만 이런 기능 브랜치 방식에는 단점이 있다. 독립 브랜치로 작업하는 기간이 길어질수록 작업 결과를 마스터로 통합하기가 어려워진다. 이 고통을 줄이고자 많은 이들이 마스터를 개인 브랜치로 수시로 리베이스하거나 머지한다.  
하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런식으로 해결할 수 없다.  
마스터를 브랜치로 '머지'하는 작업은 단방향이다. 브랜치만 바뀌고 마스터는 그대로다.  
반면 '통합'은 마스터를 개인 브랜치로 가져와서 작업한 결과를 다시 마스터에 올리는 양방향 처리를 뜻한다.  
최신 버전 관리 시스템은 복잡한 변경 사항을 텍스트 수준에서 머지하는 데는 매우 뛰어나지만, 코드의 의미는 전혀 이해하지 못한다.  
가령 함수 이름이 바뀌는 정도는 가볍게 통합해준다. 하지만 다른 브랜치에서 함수를 호출하는 코드를 추가했는데, 내 브랜치에서는 그 함수의 이름을 변경했다면 프로그램이 동작하지 않게 된다.  
이처럼 머지가 복잡해지는 문제는 기능별 브랜치들이 독립적으로 개발되는 기간이 길어질수록 기하급수적으로 늘어난다. 4주간 작업한 브랜치들을 통합하는 노력은 2주간 작업한 브랜드치들을 통합할 때보다 두 배 이상 든다. 이 떄문에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 사람이 많다.  
이 방식을 지속적 통합(CI) 또는 트렁크 기반 개발(TBD)이라 한다.  
CI에 따르면 모든 팀원이 하루에 최소 한 번은 마스터 통합한다. 이렇게 하면 다른 브랜치들과 차이가 크게 벌어지는 브랜치가 없어져서 머지의 복잡도를 상당히 낮출 수 있다.  
마스터를 건강하게 유지하고, 거대한 기능을 잘게 쪼개는 법을 배우고, 각 기능을 끌 수 있는 기능 토글을 적용하여 완료되지 않은 기능이 시스템 전체를 망차지 않도록 해야 한다. 머지의 복잡도를 줄일 수 있어서 CI를 선호하기 하지만, 가장 큰 이유는 리팩터링과 궁합이 아주 좋기 때문이다. 리팩터링을 하다 보면 코드베이스 전반에 걸쳐 자잘하게 수정하는 부분이 많을 떄가 있다. 프로그램 전체에서 자주 사용하는 함수의 이름을 바꾸는 경우가 이러한 예다.  
특히 기능별 브랜치 방식에서는 리팩터링을 도저히 진행할 수없을 정도로 심각한 머지 문제가 발생하기 쉽다. 켄트 벡이 **CI와 리팩터링을 합쳐서 익스트림 프로그래밍을 만든 이유**도 바로 두 기법의 궁함이 잘 맞기 때문이다.  
## 테스팅
리팩터링의 두드러진 특성은 프로그램의 겉보기 동작은 똑같이 유지된다는 것이다. 절차를 지켜 제대로 리팩터링하면 동작이 깨지지 않아야 한다.  
리팩터링은 단계별 변경 폭이 작아서 도중에 발생한 오류의 원인이 될만한 코드 범위가 넓지 않다.  
원인을 못 찾더라도 버전 관리 시스템을 이용하여 가장 최근에 정상 작동하던 상태로 되돌리면 된다.  
여기서 핵심은 오류를 재빨리 잡는 데 있다. 실제로 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트가 필요하다.  
그리고 이를 빠르게 실행할 수 있어야 수시로 테스트하는 데 부담이 없다. 달리 말하면 리팩터링하기 위해서는 자가 테스트 코드를 마련해야 한다는 뜻이다.  
테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가도 훨씬 안전하게 진행할 수 있도록 도와준다.  
실수로 만든 버그를 빠르게 찾아서 제거할 수 있기 떄문이다. 이떄 핵심은 테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다는 데 있다. 테스트 주기가 짧다면 단 몇 줄만 비교하면 되며, 문제를 일으킨 부분이 그 몇 줄 안에 있기 때문에 버그를 훨씬 쉽게 찾을 수 있다. 또한, 리팩터링 과정에서 버그가 생길 위험이 아주 크다는 불안감을 해소할 수 있다.  
자가 테스트 코드 없이 리팩터링할 때는 당연히 이 점을 염려해야 한다.  
안전한 자동 리팩터링만 활용한다면 테스트 없이 리팩터링해도 좋다. 그러면 활용할 수 있는 리팩터링 기법 수가 제한되지만, 자동 리팩터링들만으로도 의미 있는 효과를 보기에 충분하다.  
자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 CI와도 밀접하게 연관된다. CI에 통합된 테스트는 XP의 권장사항이자 지속적 배포(CD)의 핵심이기도 한다.
## 레거시 코드
레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다. 제 기능과 맞지 않은 함수 이름을 바로 잡고 어설픈 프로그램 구문을 매끄럽게 다듬어서 거친 원석 같던 프로그램을 반짝이는 보석으로 만들 수 있다.  
대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하기는 어렵다.  
이 문제의 정답은 당연히 테스트 보강이다. 단순 노동에 가까울 수 있다는 점을 제외하면 간단히 할 수 있어 보이지만, 막상 해보면 생각보다 훨씬 까다롭다. 보통은 테스트를 염두에 두고 설계한 시스템만 쉽게 테스트할 수 있다.  
쉽게 해결할 방법은 없다. 그나마 해줄 수 있는 조건은 레거시 코드 활용 전략에 나온 지침을 충실히ㄷ 따르는 것이다.  
주요 내용을 한 마디로 표현하면 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다는 것이다.  
이러한 틈새를 만들 때 리팩터링이 활용된다. 테스트 없이 진행하기 때문에 상당히 위험하지만 문제를 해결하기 위해서라면 감내해야 할 위험이다. 이럴 때 안전한 자동 리팩터링 도구가 있다면 큰 도움이 된다.  
테스트를 갖추고 있더라도 복잡하게 얽힌 레거시 코드를 아름다운 코드로 단번에 리팩터링하는 데는 낙관적이지 않다.  
책 저자가 선호하는 방식은 서로 관련된 부분끼리 나눠서 하나씩 공략하는 것이다. 코드의 한 부분을 훑고 넘어갈 때마다 예전보다 조금이라도 개선하려고 노력한다. 역시 캠핑 규칙에 따라 처음 왔을 때보다 깨끗하게 치우는 것이다. 레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링한다. 코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이디 당연히 이렇게 해야 한다.
## 데이터 베이스
데이터베이스 리팩터링은 진화형 데이터베이스 설계와 데이터베이스 리팩터링 기법이 현재 널리 적용되고 있다.  
이 기법의 핵심은 커다란 변경들을 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다.  
간단한 예로 필드(열)의 이름을 변경하는 경우를 생각해보면 함수 선언 바꾸기에 따르면 데이터 구조의 원래 선언과 이 데이터 구조를 호출하는 코드를 모두 찾아서 한 번에 변경해야 한다.  
그런데 예전 필드를 사용하느 데이터 모두가 새 필드를 사용하도록 변환해야 하는 부담도 따른다.  
저자는 변환을 수행하는 코드를 간단히 작성한 다음, 선언된 데이터 구조나 접근 루틴을 변경하는 코드와 함께 버전 관리 시스템에 저장한다. 그런 다음 데이터베이스를 다른 버전으로 이전할 때마다 현재 버전에서 원하는 버전 사이에 있는 모든 마이그레이션 스크립트를 실행한다.  
다른 리팩터링과 마찬가지로 이 기법도 전체 변경 과정을 작고 독립된 단계들로 쪼개는 것이 핵심이다.  
단계를 잘게 나누면 코드도 쉽게 작성할 수 있다. 그리고 여러 단계를 순차적으로 연결해서 데이터베이스의 구조와 그 안에 담긴 데이터를 큰 폭으로 변경할 수도 있다.  
데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리스하는 것이 대체로 좋다는 점에서 다른 리팩터링과 다르다.  
이렇게 하면 프로덕션 환경에서 문제가 생겼을 때 변경을 되돌리기 쉽다. 이를테면 필드 이름을 바꿀 때 첫 번째 커밋에서는 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다. 그런 다음 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다. 그다음에는 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다. 이 과정에서 발생하는 버그도 해결하면서 클라이언트 교체 작업을 모두 끝냈다면, 더는 필요가 없어진 예전 필드를 삭제한다. 이렇게 데이터베이스를 변경하는 방식은 병렬 수정(또는 팽창-수축)의 일반적인 예다.
# 리팩터링, 아키텍처, 애그니
리팩터링으로 기존 코드의 설계를 개선할 수 있다. 하지만 앞에서 말했듯이 레거시 코드는 변경하기 어려울 때가 많다. 특히 탄탄한 테스트가 뒷받침해주지 못하면 더더욱 어렵다.  
리팩터링이 아키텍처에 미치는 실질적인 효과는 요구사항 변화에 자연스럽게 대응하도록 코드 베이스를 잘 설계해준다는 데 있다.  
변경에 유연하게 대처할 수 있는 유연성 메커니즘을 소프트웨어에 심어두는 것이다. 가령 함수를 정의하다 보면 범용적으로 사용할 수 있겠다는 생각이 들 때가 있다. 그래서 다양한 예상 시나리오에 대응하기 위한 매개변수들을 추가한다. 이런 매개변수가 바로 유연성 메커니즘이다.  
매개변수를 생각나는 대로 추가하다 보면 당장의 쓰임에 비해 함수가 너무 복잡해진다. 또한 깜빡 잊은 매개변수가 있다면 앞서 추가해둔 매개변수들 때문에 새로 추가하기가 더 어려워진다. 간혹 유연성 메커니즘을 잘못 구현할 때도 있다. 요구사항이 당초 예상과 다르게 바뀌기 때문일 때도 있고, 설계한 메커니즘 자체에 결함이 있어서일 때도 있다.  
리팩터링을 활용하면 다르게 접근할 수 있다. 앞으로 어느 부분에 유연성이 필요하고 어떻게해야 그 변화에 가장 잘 대응할 수 있을지 추측하지 않고, 그저 현재까지 파악한 요구사항만을 해결하는 소프트웨어를 구축한다. 단, 이 요구를 멋지게 해결하도록 설계한다.  
진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 아키텍처도 그에 맞게 리팩터링해서 바꾼다.  
그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 메커니즘은 마음껏 추가하지만, 복잡도를 높일 수 있는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다. 호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다.  
매개변수를 추가해야 할 시점이 오면 간단한 리팩터링 기법인 **함수 매개변수화하기(11.2)**로 해결한다.  
유연성 메커니즘을 미리 추가하는 설계하는 방식을 간결한 설계, 점진적 설계, 에그니 등으로 부른다. YAGNI를 문자 그대로 해석해서 적용할 때도 있지만, 아키텍처를 전혀 고려하지 말라는 뜻은 아니다.  
YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니다.  
리팩터링으로 변경하기 어려워서 미리 생각해두면 시간이 절약되는 경우도 얼마든지 있다.  
문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 낫다는 생각하는 편의 경향은 진화형 아키텍처 원칙이 발전하는 계기가 됐다. 
# 리팩터링과 소프트웨어 개발 프로세스
리팩터링이 퍼지기 시작한 것도 익스트림 프로그래밍에 도입됐기 때문이다. XP의 두드러진 특징은 지속적 통합, 자가 테스트 코드, 리팩터링 등의 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스라는 점이다.  
자가 테스트 코드와 리팩터링을 묶어서 **테스트 주도 개발(TDD)**이라 한다.  
최초의 애자일 소프트웨어 방법론 중 하나로 등장한 XP는 그 후 수년에 걸쳐 애자일의 부흥을 이끌었다.  
애자일을 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다.  
리팩터링의 첫 번째 토대로 자가 테스트 코드다. 지속적 통합을 적용하면 팀원 각자가 수행한 리팩터링 결과를 빠르게 동료와 공유할 수 있다. 그래서 조만간 삭제될 인터페이스를 이용하여 새로운 기능을 추가하는 일을 방지할 수 있고, 리팩터링한 결과가 다른 팀원의 작업에 문제를 일으키면 즉시 알아낼 수 있다.  
자가 테스트 코드 역시 지속적 통합의 핵심 요소다.  
따라서 자가 테스트 코드, 지속적 통합, 리팩터링이라는 세기법은 서로 강력한 상승효과를 발휘한다.  
세 실천법을 적용한다면 앞 절에 설명한 YAGNI 설계 방식으로 개발을 진행할 수 있다. 리팩터링과 YAGNI는 서로 긍정적인 영향을 준다. 리팩터링이 YAGNI의 토대인 동시에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다. 추측에 근거한 수많은 유연성 메커니즘을 갖춘 시스템보다는 단순한 시스템이 변경하기가 훨씬 쉽기 때문이다. 세 가지 실천법을 잘 조화시키면 요구사항 변화에 재빠르게 대응하고 안정적인 선순한 구조를 코드베이스에 심을 수 있다.  
지속적 배포는 소프트웨어를 언제든지 릴리스할 수 있는 상태로 유지해주는데, 가령 웹사이틀 개발하는 조직은 수정사항을 하루에도 여러 차레 릴리스 할 수 있게 된다. 게다가 위험 요소도 줄이고, 기술적인 제약보다는 비즈니스 요구에 맞춰 릴리스 일정을 계확할 수 있다.  
이처럼 견고한 기술적 토대를 갖추면 좋은 아이디어를 프로덕션 코드로 반영하는 시간을 엄청나게 단축할 수 있어서 고객에게 더 나은 서비스를 제공할 수 있다.  
실무에 적용하기는 만만치 않다. 어떤 방법으로 하든 소프트웨어 개발은 여러 사람과 기계가 복잡하게 엮여 상호작용하는 까다로운 일이다. 지금까지 소개한 접근법은 이 복잡도를 다루는 데 효과적이라고 검증된 것이다. 물론 어떠한 접근법이든지 충분한 연습과 실력이 뒷받침돼야 한다.
# 리팩터링과 성능
하드 리얼타임 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다.  
빠른 소프트웨어를 작성하는 방법 세 가지를 경험했다. 그중 가장 엄격한 방법은 시간 예산 분배하는 방식으로 하드 리얼타임 시스템에서 많이 사용한다.  
이 방식에 따르면 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다.  
컴포넌트는 할당된 자원 예산을 초과할 수 없다. 단, 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있다.  
시간 예산 분배 방식은 특히 엄격한 시간 엄수를 강조한다.  
두 번째 방법은 끊임없이 관심을 기울이는 것이다. 프로그래머라면 누구나 높은 성능을 유지하기 위해 무슨 일이든 한다. 직관적이어서 흔히 사용하는 방식이지만 실제 효과는 변변치 않다. 성능을 개선하기 위해 코드를 수정하다 보면 프로그램은 다루기 어려운 형태로 변하기 쉽고, 결국 개발이 더뎌진다. 결과적으로 소프트웨어가 더 빨라지면 충분히 보상을 얻겠지만 실제로 그런 경우는 별로 없다.  
이 방식에는 성능을 개선하기 위한 최적화가 프로그램 전반에 퍼지게 되는데, 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때도 많다.  
> 아무것도 안 만드는 데도 시간이 걸린다. -론 제프리-

시스템에 대해 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다. 그러면 새로운 사실을 배우게 되는데, 십중팔구 내가 잘못 알고 있었음을 깨닫게 된다.  
성능에 대한 흥미로운 사실은, 대부분 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비한다는 것이다. 그래서 코드 전체를 고르게 최적화한다면 그중 90%는 효과가 거의 없기 때문에 시간 낭비인 셈이다. 속도를 높이기 위해 투자한 시간을 모두 날리는 행위다.  
성능 개선을 위한 세 번째 방법은 이 '90%의 시간은 낭비'라는 통계에서 착안한 것이다. 즉 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다. 그러다 성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다.  
먼저 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다. 그러면 성능에 큰 영향을 주는 작은 부분들을 찾을 수 있다. 그런 다음 전체를 고르게 최적화할 때와 마찬가지 방법으로 그 부분들을 개선한다. 이렇게 하면 성능에 큰 영향을 주는 부분만 집중해서 최적화하기 때문에 적은 노력으로 훨씬 큰 효과를 볼 수 있다.  
리팩터링할 때처럼 최적화를 위한 수정도 작은 단계로 나눠서 진행한다. 각 단꼐마다 컴파일과 테스트를 거치고 프로파일러를 다시 실행해본다. 성능이 개선되지 않다면 수정내용을 되돌린다. 이런 식으로 사용자가 만족하는 성능에 도달할 때까지 최적화 대상을 찾아서 제거하는 일을 계속한다.  
프로그램을 잘 리팩터링해두면 이런 식의 최적화에 두 가지 면에서 도움이 된다. 첫째, 성능 튜닝에 투입할 시간을 벌 수 있다. 리팩터링이 잘 되어 있다면 기능 추가가 빨리 끝나서 성능에 집중할 시간을 더 벌 수 있다. 둘쨰, 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석할 수 있다. 프로파일러가 지적해주는 코드의 범위가 더 좁아질 것이고, 그래서 튜닝하기 쉬워진다. 코드가 깔끔하면 개선안들이 더 잘 떠올릴 것이고, 그중 어떤 튜닝이 효과가 좋을지 파악하기 쉽다.  
리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다. 단기적으로 보면 리팩터링 단계에서는 성능이 느려질 수도 있다. 하지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다.
# 리팩터링의 유래
'리팩터링'이란 용어의 정확한 유래는 찾을 수 없다. 복잡하고 지저분한 코드보다는 깔끔한 코드가 수정하기 쉽고, 처음부터 깔끔하게 작성하는 경우는 거의 없다는 것을 경험을 통해 알기 때문이다. 리팩터링은 여기서 한 발 더 나아간다.  
리팩터링은 소프트웨어 개발 프로세스 전반의 핵심 요소라고 주장한다.  
스몰토크는 기능이 풍부한 소프트웨어를 빠르게 작성할 수 있는 굉장히 역동적인 환경인데, 당시 개발 환경 중에서 리팩터링을 활용해보기에 특히 좋았다.  
스몰토크는 컴파일-링크-실행 주기가 상당히 짧아서 마지막으로 컴파일한 시점을 안다면 수정 작업을 빠르게 진행할 수 있다.  
객체 지향 언어은 인터페이스만 잘 정의해두면 내부 수정이 외부에 미치는 영향을 최소로 줄일 수 있다. 워드와 켄트는 이런 환경에 특화된 소프트웨어 개발 방법을 고민했고, 그 결과로 XP가 탄생한 것이다.
# 리팩터링 자동화
리팩터링과 관련하여 지난 수십 년 사이에 일어난 가장 큰 변화는 자동 리팩터링을 지원하는 도구가 등장한 것이다. 예를 들어 인텔리제이나 이클립스에서 자바로 프로그래밍할 때는 메서드 이름을 바꾸는 작업을 메뉴에서 원하는 항목을 클릭하는 것만으로 처리할 수 있다.  
실제 리팩터링은 개발 도구가 처리해주며, 따로 테스트할 필요가 없을 정도로 안정적이다.  
자동 리팩터링 기능은 존 브랜트와 돈 로버츠가 개발한 스몰토크용에서 최초로 등장했다. 이 아이디어는 2000년대 초반에 자바 커뮤니티에 급속도로 퍼졌다. 젯브레인즈에서 인텔리제이를 출시할 때 내세운 대표 기능 중 하나가 바로 자동 리팩터링이었다.  
현재는 에디터나 독립 도구에서도 리팩터링 기능을 제공할 정도로 자동 리팩터링이 흔해졌다.  
리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다. 가령 '찾아 바꾸기'기능으로 이름을 변경하거나, **변수 추출하기(6.3)**를 위해 간단히 코드를 재구성하는 식이다.  
이 방식은 허점이 많기 때문에 테스트해보기 전에는 결과를 신뢰해서는 안 된다. 하지만 리팩터링에 첫 발을 내딛는 데는 유용하다.  
저자는 완성도 높은 리팩터링 도구가 없을 때는 이맥스에 해당 매크로를 만들어 활용하는 식으로 리팩터링 속도를 높일 것이다.  
자동 리팩터링을 제대로 구현하려면 코드를 텍스트 상태가 아닌, 구문 트리로 해석해서 다뤄야 한다. 구문 트리를 조작하는 방식이 코드의 원래 의미를 보존하는 데 훨씬 유리하기 때문이다. 그래서 뛰어난 IDE가 자동 리팩터링도 더 풍부하게 제공하는 경우가 많다. IDE는 리팩터링뿐 아니라 코드 탐색과 린팅(linting; 정적분석)을 비롯한 다양한 기능을 구현하는 데 구문 트리를 활용한다. 텍스트와 구문 트리를 함께 활용하기 때문에 단순한 코드 에디터 수준을 훌쩍 뛰어넘는다.  
하지만 단순히 구문 트리를 해석해서 수정하는 것만으로는 리팩터링을 구현할 수 없다. 변경된 구문 트리를 다시 에디터 화면에 텍스트로 바꿔 표현해야 한다. 그래서 리팩터링 기능을 제대로 구현하기란 상당히 어렵다. 이 기능을 즐겨 쓰는 나조차도 이러한 사실을 인지하지 못할 때가 많다. 정작 타입 언어라면 훨씬 안전하게 구현할 수 있는 리팩터링 수가 늘어난다. **함수 이름 바꾸끼(6.5)**를 적용하는 경우를 생각해보자.  
Salesperson클래스와 Server  클래스 모두에 addClinet()라는 메서드가 있다고 하자. 그중 Salesperson 클래스에 정의된 addClinet()의 이름을 변경하고자 한다. Server 클래스의 addClinet()를 호출하는 코드 중에서 어느것이 Salesperson클래스에 해당하는지 구분하기 쉽지 않다.  그래서 도구는 이 메서드를 호출하는 지점의 목록을 제공할 것이고, 우리는 목록을 일일이 살펴보면서 이름을 바꿀 대상을 직접골라야 한다.  
이런 식의 리팩터링은 안전하지 않기 때문에 반드시 테스트를 거쳐야한다.  
이정도만 제공해도 꽤 도움이 되지만, 자바 코드라면 같은 작업을 완벽히 안전하면서도 자동으로 처리할 수 있다. 도구에서 자바의 정적 타입 능력을 활용하여 메서드가 속한 클래스를 정확히 알아낼 수 있기 때문에, 변경할 메서드만 제대로 골라낼 거라고 믿을 수 있다.  
간혹 도구에서 그 이상까지 처리해주는 경우도 있다. 가령 변수 이름을 바꾸려 하면 코드는 물론 주석에 쓰인 이름도 함께 바꿀지 물어볼 것이다. 혹은 **함수 추출하기(6.1)** 를 적용할 때, 새 함수의 본문과 같은 코드를 찾으면 해당 코드를 강조해 보여주면서, 이 역시 추출한 함수를 호출하게끔 바꾸라고 권하기도 하다.  
이처럼 IDE가 제공하는 리팩터링 기능이 강력하기 때문에 손에 익은 텍스트 에디터만 고집하지 말고 IDE를 사용하는 편이 프로그래밍 효율 면에서 훨씬 유리하다.  
