| 내용 | 최초 작성일 | 참고 |
|---|:---:|---:|
| 기본 위젯 | 2021-08-01 | 소문난 명강의 : 오준석의 플러터 생존 코딩 |

화면을 구성하는 컴포넌트를 `위젯`이라고 한다.  
화면을 구성하려면 다양한 위젯을 조합해야하므로 가능하면 많은 위젯을 아는 것이 좋다.  
[공식 웹사이트](https://flutter.dev/docs/development/ui/widgets)에서 다양한 위젯을 알 수 있다.  
[다트패드](https://dartpad.dev)에서 예제를 연습 할 수 있다.  
다트패드에서는 다트 언어뿐만 아니라 플러터 코드도 실행 할 수 있다.  
다프태드에 접속한 뒤 'New Pad'를 클릭하고 Flutter를 선택한다.  
선택하면 아래의 샘플 소스가 제공된다.
```dart
import 'package:flutter/material.dart';

final Color darkBlue = Color.fromARGB(255, 18, 32, 47);

void main() {
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      theme: ThemeData.dark().copyWith(scaffoldBackgroundColor: darkBlue),
      debugShowCheckedModeBanner: false,
      home: Scaffold(
        body: Center(
          child: MyWidget(),
        ),
      ),
    );
  }
}

class MyWidget extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Text('Hello, World!', style: Theme.of(context).textTheme.headline4);
  }
}

```
실습을 하기 위해 아래의 기본 코드를 바탕으로 예제를 작성해 실행해본다.
```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: MyHomePage(),
        );
    }
}
//여기까지는 공통 코드이다.

//여기부터 수정한다.
class MyHomePage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('제목'),
            ),
            body: Text('여기에 작성'),
        );
    }
}
```
# 화면 배치에 쓰는 기본 위젯
위젯 중에는 화면을 구성하고 배치하는 데 뼈대가 되는 것이 있다.  
화면 배치에 사용되는 기본 위젯을 알아본다.
## Container
아무것도 없는 위젯이다. 다양한 프로퍼티를 가지고 있기 때문에 사용하기에 따라서 다양한 응용이 가능하다.  
자주 사용되는 위젯이다.
```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: MyHomePage(),
        );
    }
}

class MyHomePage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('제목'),
            ),
            body: Container(
                color: Colors.red,
                width: 100,
                height: 100,
                padding: const EdgeInsets.all(8.0),
                margin: const EdgeInsets.all(8.0),
            ),
        );
    }
}

```
가로와 세로 길이, 색, 안쪽 여백, 바깥쪽 여백 등의 설정이 가능하고 child 프로퍼터로 또 다른 위젯을 자식으로 가질 수 있다.
## Column
수직 방향으로 위젯들을 나란히 배치하는 위젯으로 레이아웃은 대부분 Column과 Row를 조합하여 만들기 때문에 매우 자주 사용된다.  
children 프로퍼터에는 여러 위젯의 리스트를 지정할 수 있다. 지정한 위젯들은 세로로 배치된다.
```dart
Column(
    children: <Widget> [
        [위젯],
        [위젯],
        [위젯],
    ]
)
```
```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: MyHomePage(),
        );
    }
}

class MyHomePage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('수직 방향으로 빨강, 초록, 파란색'),
            ),
            body: Column(
                children: <Widget> [
                    Container(
                        color: Colors.red,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),
                    ),
                    Container(
                        color: Colors.green,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),
                    ),
                    Container(
                        color: Colors.blue,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),
                    ),                                        
                ]
            ),
        );
    }
}

```
## Row
Column과 반대로 수평 방향으로 위젯들을 나란히 배치하는 위젯이다.  
Column과 같이 children 프로퍼티에 여러 위젯을 나열한다. Row, Column과 같이 방향성이 있는 위젯은 mainAxis와 crossAxis관련 프로퍼티가 있다.
```dart
Row(
    mainAxisSize: MainAxisSize.max,
    minAxisAlignment: MainAxisAlignment.center,
    crossAxisAlignment: CrossAxisAlignment.center,
    children: <Widget>[
        [위젯],
        [위젯],
        [위젯],
    ],    
)
```
```dart
import 'package:flutter/material.dart';

void main() => runApp(MyApp());

class MyApp extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return MaterialApp(
            title: 'Flutter Demo',
            theme: ThemeData(
                primarySwatch: Colors.blue,
            ),
            home: MyHomePage(),
        );
    }
}

class MyHomePage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('수평 방향으로 빨강, 초록, 파란색'),
            ),
            body: Row(
                mainAxisSize: MainAxisSize.max, //가로로 꽉 채우기
                mainAxisAlignment: MainAxisAlignment.center, //가로 방향으로 가운데 정렬하기
                crossAxisAlignment: CrossAxisAlignment.center, //세로 방향으로 가운데 정렬하기
                children: <Widget> [
                    Container(
                        color: Colors.red,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),                        
                    ),
                    Container(
                        color: Colors.green,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),                        
                    ),
                    Container(
                        color: Colors.blue,
                        width: 100,
                        height: 100,
                        padding: const EdgeInsets.all(8.0),
                        margin: const EdgeInsets.all(8.0),                        
                    ),                                        
                ],
            ),
        );
    }
}
```
mainAxis는 위젯의 기본 방향을 나타낸다.  
Row는 오른쪽, Column은 아래쪽이 mainAxis가 된다.  
crossAxis는 기본 방향의 반대 방향을 나타낸다. Row는 아래쪽, Column은 오른쪽이 crossAxis가 된다.  
각 프로퍼티에 지정할 수 있는 상수는 다음과 같다.
**MainAxisSize에 정의된 상수**
| 상수 | 설명 |
|---|:---:|
| max | 최대 크기, 남은 공간을 모두 차지한다. |
| min | 최소 크기, 포함된 콘텐츠의 크기만큼만 차지한다. |

**MainAxisAlignment와 CrossAxisAlignment에 정의된 상수**
| 상수 | 설명 |
|---|:---:|
| center | 가운데 정렬. |
| start | 왼쪽 정렬. |
| end | 오른쪽 정렬. |
| spaceEvenly | 같은 크기만큼 양 옆에 공간을 둔다. |
| spaceBetween | 절반 크기만큼 양 옆에 공간을 둔다. |
| spaceAround | 양 옆에 공간을 만들지 않는다. |

## Stack
Stack위젯은 children에 나열한 여러 위젯을 순서대로 겹치게 한다.  
예를 들어 사진 위에 글자를 표현하거나 화면 위에 로딩 표시를 하는 상황에 사용할 수 있다.  
Row, Column과 같으며 순서는 children 프로퍼터에 정의한 리스트에 먼저 작성한 위젯이 가장 아래에 위치하고, 나중에 작성한 위젯이 위쪽에 위치하게 된다.
```dart
Stack(
    children: <Widget> [
        Container(
            color: Colors.blue,
            width: 100,
            height: 100,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),                        
        ),
        Container(
            color: Colors.green,
            width: 80,
            height: 80,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),                        
        ),        
        Container(
            color: Colors.blue,
            width: 60,
            height: 60,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),                        
        ),        
    ]
)
```
## SingleChildScrollView
Column을 사용하여 위젯들을 나열하다가 화면 크기를 넘어서면 스크롤이 필요하다.  
SingleChildScrollView로 감싸면 스크롤이 가능하게 할 수 있다.  
SingleChildScrollView은 말 그대로 하나의 자식을 포함하는 스크롤 가능한 위젯으로,  
SingleChildScrollView은 하나의 자식 위젯을 가져야한다.  
Column은 기본적으로 표시할 위젯의 크기만큼 가로 길이를 가지고, ListBody를 사용하면 스크롤 가능 영역이 가로로 꽉 차기 때문에  
사용자가 스크롤하기 더 쉽다.
```dart
final items = List.generate(100, (i) => i).toList();

SingleChildScrollView(
    child: ListBody(
        children: items.map((i) => Text('$i')).toList(),
    ),
)
```
## ListView, List Title
ListView는 리스트를 표시하는 위젯이다. SingleChildScrollView와 ListBody과 동일한 효과를 내지만 좀 더 리스트 표현에 최적화된 위젯이다.  
ListView에 표시할 각 항목의 레이아웃은 직접 정의해도 되지만 리스트 아이템을 쉽게 작성할 수 있는 ListTitle 위젯을 사용하면 편하다.  
ListView의 children 프로퍼터에 다수의 위젯을 배치하면 정적인 리스트를 쉽게 만들 수 있다.
```dart
ListView(
    scrollDirection: Axis.vertical,
    children: <Widget>[
        ListTile(
            leading: Icon(Icon.home),
            title: Text('Home'),
            traling: Icon(Icon.navigate_next),
            onTap: () {},
        ),
        ListTile(
            leading: Icon(Icon.home),
            title: Text('Event'),
            traling: Icon(Icon.navigate_next),
            onTap: () {},
        ),
        ListTile(
            leading: Icon(Icon.home),
            title: Text('Camera'),
            traling: Icon(Icon.navigate_next),
            onTap: () {},
        ),                
    ],
),
```
ListTile위젯은 leading, title, trailing 프로퍼티가 각각 왼쪽, 중앙, 오른쪽 위치를 담당해 자유롭게 아이콘이나 글자를 배치할 수 있다.  
ListTile의 onTap프로퍼티에는 리스트의 항목을 탭했을 때 실행해야 하는 동작을 정의한 함수를 작성한다.  
**NOTE_이벤트**
```
onPressed, onChanged, onTop처럼 on으로 시작하는 프로퍼티에 작성한 함수는 사용자 동작에 의해 호출된다.
어떤 동작에 의해 수행되기 때문에 클릭, 변경, 탭 이벤트 등으로 부르기도 한다.
```
## GridView
열 수를 지정하여 그리드 형태로 표시하는 위젯  
GridView.count() 생성자는 간단하게 그리드를 작성해준다.  
crossAxisCount 프로퍼티에 열 수를 지정할 수 있다.
```dart
GridView.count(
    crossAxisCount: [열 수],
    children: <Widget> [
        [위젯],
        [위젯],
        [위젯],
    ],
)
```
2열 그리드에 빨강, 녹색, 파랑을 나열해본다.
```dart
GridView.count(
    crossAxisCount: 2,
    children: <Widget>[
        Container(
            color:Colors.red,
            width: 100,
            height: 100,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),            
        ),
        Container(
            color:Colors.green,
            width: 100,
            height: 100,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),            
        ),
        Container(
            color:Colors.blue,
            width: 100,
            height: 100,
            padding: const EdgeInsets.all(8.0),
            margin: const EdgeInsets.all(8.0),            
        )        
    ]
)
```
## PageView
여러 페이지를 좌우로 슬라이드하여 넘길 수 있도록 해주는 위젯  
children 프로퍼티에 각 화면을 표현할 위젯을 여러 개 준비하여 지정하면 화면을 좌우로 슬라이드할 수 있다.  
하지만 `Tab과 연동하여 사용하지 않으면 좌우로 슬라이드가 가능한지 사용자가 모를 수 있기 때문에 단독으로는 사용하지 않는다`.
```dart
PageView(
    children: <Widget>[
        [위젯],
        [위젯],
        [위젯],
    ]
)
```
빨강, 초록, 파랑 페이지를 좌우로 슬라이드되도록 해본다.  배치되는 위젯 하나는 하나의 페이지를 담당한다.
```dart
PageView(
    children: <Widget>[
        Container(
            color:Colors.red
        ),
        Container(
            color:Colors.green
        ),
        Container(
            color:Colors.blue
        ),                
    ]
)
```
## AppBar, TabBar, Tab, TabBarView
이 위젯들을 조합하여 PageView와 유사하지만 페이지와 탭이 연동되는 화면을 구성할 수 있다.
```dart
class MyHomePage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return DefaultTabController( //Scaffold를 감싸고
            length: 3, //탭수 지정
            child: Scaffold(
                appBar: AppBar(
                    title: Text('Tab'),
                    bottom: TabBar( //Scaffold의 bottom 프로퍼티에 TabBar지정
                        tabs: <Widget>[ //tabs프로퍼티에 tab의 리스트 지정
                            Tab(icon: Icon(Icons.tab_faces)),
                            Tab(text: '메뉴2'),
                            Tab(icon: Icon(Icons.info), text: '메뉴3'),
                        ],
                    ),
                ),
                body: TabBarView( //Scaffold의 body 프로퍼티에는 TabBarView 패치
                    children: <Widget> [ //children 프로퍼티에 표시할 화면 배치
                        children: <Widget> [
                            Container(color: Colors.yellow,),
                            Container(color: Colors.orange,),
                            Container(color: Colors.red,),
                        ]
                    ]
                )
            )
        )
    }
}
```
## BottomNavigationBar
하단에 2~5개 탭 메뉴를 구성할 수 있는 위젯으로 각 탭을 클릭하여 화면을 전환할 때 사용  
Scaffold의 프로퍼티 중에서 bottomNavigationBar프로퍼티를 정의하고 items프로퍼티에 BottomNavigationBarItem위젯들을 나열한다.  
icon과 label, 프로퍼티를 정의하여 간단히 탭 바를 구성할 수 있다.
```dart
Scaffold(
    bottomNavigationBar: BottomNavigationBar(items:[
        BottomNavigationBarItem(
            icon: Icon(Icons.home),
            label: 'Home',
        ),
        BottomNavigationBarItem(
            icon: Icon(Icons.person),
            label: 'Profile',
        ),
        BottomNavigationBarItem(
            icon: Icon(Icons.notifications),
            label: 'Notification',
        ),                
    ])
)
```
# 위치, 정렬, 크기를 위한 위젯
화면을 구성할 때는 배치한 위젯의 위치를 정해야한다.  
위젯 중에는 위젯 크기나 위치, 정렬, 등을 보조하는 위젯이 있다.
## Center
중앙으로 정렬 시키는 위젯으로 상당히 자주 사용한다.  
child 프로퍼티에 중앙에 배치할 위젯을 생성한다.
```dart
Center(
    child: [위젯],
)
```
빨간 사각형을 중앙에 표시해본다.
```dart
Center(
    child: Container(
        color: Colors.red,
        width: 100,
        height: 100,
    )
)
```
## Padding
안쪽 여백을 표현할 때 사용하는 위젯이다.  
안쪽 여백은 padding 프로퍼티에 값을 지정한다.  
이 값은 EdgeInsets클래스를 사용하여 설정하며 다음과 같이 여러 방법을 제공한다. 앞에 const를 붙이면 컴파일 타임에 상수로 정의되어 다시 사용되는 부분이 있을 경우 메모리에 잇는 값을 재사용하는 이득이 있다.
```dart
Padding(
    padding: const EdgeInsets.all(40.0),
    child: [위젯],
)
```
EdgeInsets는 여러 함수를 제공한다. all()함수는 네 방향 모두 같은 값을 지정한다.
```dart
EdgeInsets.all([double])
```
only()함수는 상하좌우 중에서 원하는 방향에만 값을 지정한다.  
지정하지 않은 방향에는 기본값 0.0이 지정
```dart
EdgeInsets.only({left: [왼쪽], top: [위], right: [오른쪽], bottom: [아래]})
```
fromLTRB() 함수는 네 방향의 값을 각각 지정한다.
```dart
EdgeInsets.fromLTRB([왼쪽],[위],[오른쪽],[아래])
```
빨간 사각형의 사방에 40만큼 패딩을 적용해본다
```dart
Padding(
    padding:const EdgeInsets.all(40.0),
    child: Container(
        color: Colors.red,
    ),
)
```
## Align
자식 위젯의 정렬 방향을 정할 수 있는 위젯이다.  
원하는 방향으로 위젯을 정렬할 떄 사용한다.
```dart
Align(
    alignment: Alignment.bottomRight,
    child: [위젯],
)
```
자식 위젯을 정렬하기 위해서는 alignment 프로퍼터에 정렬하고자 하는 방향을 정의해야한다.  
alignment프로퍼티에 정의할 수 있는 값들은 Alignment클래스에 정의되어 있다.
| 상수 | 설명 |
|---|:---:|
| bottomLeft | 하단 왼쪽 |
| bottomCenter | 하단 중앙 |
| bottomRight | 하단 오른쪽 |
| centerLeft | 중단 왼쪽 |
| center | 중단 중앙 |
| centerRight  | 중단 오른쪽 |
| topLeft | 상단 왼쪽 |
| topCenter | 상단 중앙 |
| topRight | 상단 오른쪽 |  
하단 오른쪽에 빨간 박스를 정렬해본다.
```dart
Align(
    alignment: Alignment.bottomRight,
    child: Container(
        color: Colors.red,
        width: 100,
        height: 100,
    ),
)
```
## Expanded
자식 위젯의 크기를 최대한으로 확장시켜주는 위젯이다.  
여러 위젯에 동시에 적용하면 flex 프로퍼터에 정숫값을 지정하여 비율을 정할 수 있으며 기본 값은 1이다.
```dart
Column(
    children: <Widget>[
        Expanded(
            flex: [비율], //기본값 1
            child: [위젯],
        ),
        Expanded(
            child: [위젯],
        ),
        Expanded(
            child: [위젯],
        ),         
    ],
),
```
그럼 빨강, 초록, 파랑 박스를 2:1:1로 수직으로 배치해본다.
```dart
Column(
    children: <Widget>[
        Expanded(
            flex: 2,
            child: Container(
                color: Colors.red,
            ),
        ),
        Expanded(
            child: Container(
                color: Colors.green,
            ),
        ),
        Expanded(
            child: Container(
                color: Colors.blue,
            ),
        ),        
    ]
),
```
## SizedBox
위젯 중에는 크기에 관련된 프로퍼티가 없는 위젯이 많은데, 그러한 위젯을 특정 크기로 만들고 싶을 때 사용한다.  
width에 가로 길이, height에 세로 길이를 double타입으로 지정한다. SizedBox를 child없이 단독으로 사용하면 단순히 여백을 표현하는 데 사용할 수 있다.
```dart
SizedBox(
    width: [가로 길이],
    height: [세로 길이],
    child: [위젯],
)
```
빨간 박스를 100, 100크기로 만들어본다. 100.0은 소수점 아래를 생략하여 100으로 작성해도 된다.
```dart
SizedBox(
    width: 100,
    height: 100,
    child: Container(
        color: Colors.red,
    ),
),
```
이전처럼 Container에 길이를 직접 지정하면 코드가 더 간결해지지만 대부분의 위젯은 크기 지정 프로퍼티를 가지고 있지 않기 때문에 SizedBox를 많이 사용한다.
## Card
카드 형태의 모양을 제공하는 위젯이다.  
기본적으로 크기가 0이므로 자식 위젯의 크기에 따라 크기가 결정된다.  
```dart
Card(
    shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16.0),
    ),
    elevation: [실숫값], //그림자 깊이
    child: [위젯],
),
```
- elevation 프로퍼티를 지정하여 그림자의 깊이를 조정할 수 있다.  
- shape프로퍼티는 카드 모양을 변경하는 방법을 제공한다.
- borderRadius 프로퍼티에 BorderRadius.circular()메서드를 지정하여 카드 모서리의 둥근 정도를 실숫값으로 조절한다. 값이 클수록 더 둥글게 된다.
```dart
Center(
    child: Card(
        shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16.0),
        ),
        elevation: 4.0, //그림자 길이
        child: Container(
            width: 200,
            height: 200,
        ),
    ),
),
```
중앙에 정렬된 위젯은 이렇게 Center위젯으로 감싼 것으로 보면 된다.
# 버튼 계열 위젯
플러터는 여러 종류의 버튼 위젯을 제공한다.
## ElevatedButton
입체감을 가지는 버튼 위젯이다.
```dart
ElevatedButton(
    child: Text('RaisedButton'),
    onPressed: () {
        //실행될 코드 작성
    },
),
```
버튼 위젯들은 모두 onPressed프로퍼티에 버튼이 클릭되었을 때 실행될 함수를 반드시 정의해줘야 버튼이 활성화되며 클릭 가능하다.  
만약 null을 지정하면 버튼이 클릭되지 않는 비활성화 상태가 된다.
## TextButton
평평한 형태의 버튼이다.
```dart
TextButton(
    child: Text('TextButton'),
    onPressed: () {},
)
```
## IconButton
아이콘을 표시하는 버튼 위젯이다.
```dart
IconButton(
    icon: Icon(Icons.add),
    color: Colors.red,
    iconSize: 100.0, //기본값 24.0
    onPressed: () {},
)
```
아이콘의 크기나 색을 지정할 수 있다. 이 위젯은 다른 위젯과 다르게 자식 위젯을 포함할 수 없다. 대신 아이콘을 icon프로퍼티에 작성하고 크기는 iconSize프로퍼티로 설정한다.
## FloatingActionButton
입체감 있는 둥근 버튼 위젯이다.
```dart
FloatingActionButton(
    child: Icon(Icons.add),
    onPressed: () {},
),
```
Scaffold의 floatingActionButton 프로퍼티에 바로 사용할 수도 있고 일반적인 버튼처럼 단독 사용할 수 있다.
# 화면 표시용 위젯
버튼과 더불어 화면 구성시 가장 자주 사용되는 위젯인 텍스트, 이미지, 아이콘, 프로그레스바를 알아본다.
## Text
글자를 표시하는 위젯이다.  
Text위젯은 기본적으로 첫 번째 인수에 문자열을 지정하여 Text('글자') 형태로 사용하는데 style프로퍼티에 TextStyle 클래스의 인스턴스를 지정하여 다양한 글자를 표현할 수 있다.
```dart
Text(
    'Hello World',
    style: TextStyle(
        fontSize: 40.0,
        fontStyle: FontStyle.italic,
        fontWeight: FontWeight.bold,
        color: Colors.red,
        letterSpacing: 4.0,
    ),
),
```
Text클래스의 첫 번째 인수는 필수 프로퍼티이고 이름 없는 인수이다.  
style뿐만 아니라 모든 이름 있는 인수는 옵션 성격이므로 필요한 것은 선택적으로 사용할 수 있다.
## Image
이미지를 표시하는 위젯이다.  
플러터에서는 네트워크에 있는 이미지를 간단히 표시할 수 있다. network()메서드에 이미지 파일의 URL을 입력하기만 하면 된다.
```dart
Image.network('url')
```
물론 asset()메서드로 이미지 파일을 직접 표시할 수도 있다.  
이미지 파일을 사용하려면 프로젝트 내에 별도의 폴더를 만든 후 이미지 파일을 복사해둔다. assets폴더를 주로 사용한다.  
이미지 파일을 사용할 수 있도록 pubspec.yaml파일을 수정해야 한다.
```xml
flutter:
    assets:
        - assets/
```
파일을 수정하면 `flutter pub get` 명령을 실행하여 프로젝트에서 이미지 파일에 접근할 수 있게 한다.
```dart
Image.asset('assets/sample.jpg')
```
## Icon
아이콘 위젯은 단독으로도 사용하지만 메뉴나 리스트, 버튼과의 조합으로 사용한다.
```dart
Icon(
    Icons.home,
    color: Colors.red,
    size: 60.0, //기본값 24.0
)
```
머티리얼 디자인용 기본 아이콘들은 Icons클래스에 상수로 미리 정의되어 있다. Icon클래스의 첫 번째 인수에 Colors클래스에 미리 정의된 다양한 머티리얼 아이콘을 지정한다. 색상이나 크기 등을 자유롭게 지정할 수 있다.
## Progress
로딩 중이거나 오래 걸리는 작업을 할 때 사용자에게 진행 중임을 보여주는 용도로 사용하는 위젯이고, 두 종류를 제공한다.
```dart
CircularProgressIndicator()
LinearProgressIndicator()
```
- CircularProgressIndicator은 둥근 형태의 프로그레스바이다. 일반적으로 다른 화면 위에 겹쳐서 표시하므로 Stack위젯으로 겹쳐서 사용한다. 
- LinearProgressIndicator은 선 형태의 프로그레스바이다.
## CircleAvatar
프로필 화면 등에 많이 사용되는 원형 위젯이다.  
child프로퍼티에 정의한 위젯을 원형으로 만들어준다.  
```dart
CircleAvatar(
    child: Icon(Icons.person),
),
```
네트워크상에 존재하는 이미지를 표시한다면 child프로퍼티가 아닌 backgroundImage 프로퍼티에 NetworkImage 클래스의 인스턴스를 지정해야 네트워크에서 받아온 이미지가 원형으로 표시된다.
```dart
CircleAvatar(
    backgroundImage: NetworkImage([이미지 URL])
)
```

### 정리
- 플러터의 UI를 구성하는 모든 요소를 위젯(Widget)이라고 한다.
- 위치나 크기 같은 속성 또한 위젯을 사용한다.

# 입력용 위젯
플러터에는 많은 입력용 위젯이 있다. 
## TextField
글자를 입력 받는 위젯이다.  
InputDecoration클래스와 함께 사용하면 힌트 메시지나 외곽선등의 꾸밈 효과를 간단히 추가할 수 있다.
```dart
TextField(
    decoration: InputDecoration(
        border: OutlineInputBorder(), //외곽선
        labelText: '여기에 입력하세요', //힌트
    ),
)
```
decoration 프로퍼티를 활용하면 다양한 효과를 줄 수 있다.  
## CheckBox와 Switch
설정 화면 등에 많이 사용되는 체크박스, 라디오 버튼, 스위치를 표현하는 위젯이다.  
Checkbox와 Switch는 모양만 다를 뿐 사용 방법은 동일하다.
```dart
var isChecked = false;

Checkbox(
    value: isChecked,
    onChanged: (value) {
        setState() {
            isChecked = value;
        },
    },
),

Switch(
    value: isChecked,
    onChanged: (value) {
        setState() {
            isChecked = value;
        },
    },
),
```
상태를 나타내는 블리언 타입의 변수가 필요하고 value 프로퍼티에 설정해야한다.  
onChanged이벤트는 체크값이 변할 때마다 발생하는데 여기서 변경된 값이 불리언 value인수로 넘어오며 setState() 함수를 통해 value 프로퍼티에 지정한 변숫값을 변경하여 UI를 다시 그린다.  
아래 소스는 상태를 나타내는 변수가 등장하므로 StatefulWidget이어야 한다.  
_isChecked변수와 Checkbox와 Switch관련 부분의 위치를 확인
```dart
class MyHomePage extends StatefulWidget {
    @override
    _MyHomePageSate createState() => _MyHomePageState();
}

class _MyHomePageState extends State<MyHomePage> {
    var _isChecked = false;

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('Checkbox / Radio / Switch'),
            ),
            body: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Center(
                    child: Column(
                        mainAxisAlignment: MainAxisAlignment.center,
                        children: <Widget> [
                            Checkbox(
                                value: _isChecked,
                                onChaged: (value) {
                                    setState(() {
                                        _isChecked = value;
                                    });
                                },
                            ),
                            SizeBox(
                                height: 40,
                            ),
                            Switch(
                                value: _isChecked,
                                onChanged: (value) {
                                    setState(() {
                                        _isChecked = value;
                                    });
                                },
                            ),
                        ],
                    ),
                ),
            ),
        );
    }
}
```
## Radio와 RadioListTile
선택 그룹 중 하나를 선택할 때 사용하는 위젯이다.  
터치 영역에 따라 Radio또는 RadioListTitle로 나눠진다.  
Radio는 그룹 내에서 하나만 선택할 때 사용한다. 그룹이 되는 항목을 열거형(enum)으로 정의하고 groupValue프로퍼티에 열거형으로 정의한 Gender 타입의 변수를 지정하고, onChanged이벤트에 변경된 값을 반영한다. ListTtile대신 RadionListTile을 사용하면 가로 전체가 터치 영역이 된다.
```dart
enum Gender { MAN, WOMEN }

Gender _gender = Gender.MAN;

...생략...

//Radio는 라디오 영역만 터치 영역으로 인식
ListTitle(
    title: Text('남자'),
    leading: Radion(
        value: Gender.MAN,
        groupValue: _gender,
        onChanged: (value) {
            setState(() {
                _gender = value;
            });
        },
    ),
),
ListTitle(
    title: Text('여자'),
    leading: Radion(
        value: Gender.WOMEN,
        groupValue: _gender,
        onChanged: (value) {
            setState(() {
                _gender = value;
            });
        },
    ),
)

```
ListTile과 RadioListTitle를 사용하면 열거형 Gender의 위치는 클래스와 동일한 레벨로 작성하면 된다.
```dart
enum Gender { MAN, WOMEN }

class _MyHomePageState extends State<MyHomePage> {
    Gender _gender = Gender.MAN;

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('Radio / RadioListTitle'),
            ),
            body: Padding(
                padding: const EdgeInsets.all(8.0),
                child: Center(
                    child: Column(
                        mainAxisAlignment: MainAxisAlignment.cetner,
                        crossAxisAlignment: CrossAxisAlignment.center,
                        child: <Widget> [
                            ListTitle(
                                title: Text('남자'),
                                leading: Radion(
                                    value: Gender.MAN,
                                    groupValue: _gender,
                                    onChanged: (value) {
                                        setState(() {
                                            _gender = value;
                                        });
                                    },
                                ),
                            ),
                            ListTitle(
                                title: Text('여자'),
                                leading: Radion(
                                    value: Gender.WOMEN,
                                    groupValue: _gender,
                                    onChanged: (value) {
                                        setState(() {
                                            _gender = value;
                                        });
                                    },
                                ),                                
                            ),
                            SizeBox(
                                height: 40,
                            ),
                            RadioListTitle(
                                title: Text('남자'),
                                value: Gender.MAN,
                                groupValue: _gender,
                                onChanged: (value) {
                                    setState(() {
                                        _gender = value;
                                    });
                                },
                            ),
                            RadioListTitle(
                                title: Text('여자'),
                                value: Gender.WOMEN,
                                groupValue: _gender,
                                onChanged: (value) {
                                    setState(() {
                                        _gender = value;
                                    });
                                },
                            ),
                        ],
                    ),
                ),
            ),
        );
    }
}
```
## DropDownButton
여러 아이템 중 하나를 고를 수 있는 콤보박스 형태의 위젯이다.  
value 프로퍼티에 표시할 값을 지정합니다. items 프로퍼티에는 표시할 항목을 DropdownMenuItem클래스의 인스턴스들을 담은 리스트로 지정해야 한다. 상태를 가지므로 StatefulWidget으로 작성해야한다.
```dart
final _valueList = ['첫 번째','두 번째','세 번째'];
var _selectedValue = '첫 번째';

...생략...
//Scaffold의 body에 작성
DropdownButton(
    value: _selectedValue,
    items: _valueList.map(
        (value) {
            return DropdownMenuItem(
                value: value,
                child: Text(value),
            );
        },
    ).toList(),
    onChanged: (value) {
        setState((){
            _selectedValue = value;
        });
    },
),
```
map()함수를 사용하여 _valueList 리스트의 문자열 3개를 DropdownMenuItem인스턴스 3개로 변환했다.  
toList()함수를 사용하여 다시 리스트로 변환시켜 items 프로퍼티에 이 리스트를 지정했다.  
map()함수를 사용하여 값 리스트를 위젯 리스트로 변환하는 코드가 자주 사용한다.
# 다이얼로그
다이얼로그는 사용자의 확인을 요구하거나 메시지를 표시하는 용도로 자주 사용한다.
## AlertDialog
머티리얼 디자인의 유저 확인용 다이얼로그다.  
AlertDialog를 표시하려면 showDialog() 함수의 builder 프로퍼티에 AlertDialog 클래스의 인스턴스를 변환하는 함수를 작성하면 된다.  
showDialog() 함수의 barrierDismissible프로퍼티는 다이얼로그 바깥 부분을 탭(터치)해도 닫히게 할 것인지 정한다.
```dart
showDialog(
    context: context,
    barrierDismissble: false, //사용자가 다이얼로그 바깥을 터치하면 닫히지 않음
    builder: (BuildContext context) {
        return AlertDialog(
            title: Text('제목'),
            context: SingleChildScrollView(
                child: ListBody(
                    children: <Widget>[
                        Text('Alert Dialog이다.'),
                        Text('OK를 눌러 닫는다'),
                    ],
                ),
            ),
            actions: <Widget>[
                TextButton(
                    child: Text('OK'),
                    onPressed: () {
                        //다이얼로그 닫기
                        Navigator.of(context).pop();
                    },
                ),
                TextButton(
                    child: Text('Cancel'),
                    onPressed: () {
                        //다이얼로그 닫기
                        Navigator.of(context).pop();
                    }
                ),
            ],            
        );
    },
)
```
AlertDialog 클래스는 title과 content, actions 영역을 정의해준다.  
title은 말 그대로 제목 영역이며, content는 내용 영역이다.  
여기서는 SingleChildScrollView와 ListBody클래스를 사용하여 ListView와 동일한 효과를 가지도록 했다.  
actions프로퍼티에는 버튼들을 정의한다. 여기서는 TextButton 두 개를 정의했고 각 버튼을 클릭할 때 Navigator.of(context).pop() 호출하여 다이얼로그를 닫는다.
## DataPicker
날짜를 선태할 때 사용한다.  
showDataPicker()함수를 호출하면 달력이 표시되며 날짜를 선택하고 'OK'버튼을 누르면 날짜를 반환한다.
```dart
Future<DateTime> selectedDate = showDatePicker(
    context: context,
    initialDate: DateTime.now(), //초깃값
    firstDate: DateTime(2018), //시작일 2018.01.01
    lastDate: DateTime(2030), //마지막일 2030.01.01
    builder: (BuildContext context, Widget child) {
        return Theme(
            data: ThemeData.dark(), //다크 테마
            child: child,
        );
    },
);
```
함수의 프로퍼티에는 context를 인수로 전달해야 하고, initialDate에는 초기 선탯값을 DateTime의 인스턴스로 정의한다. 여기서 사용된 DateTime.now() 함수는 오늘 날짜를 나타낸다.  
firstDate와 lastDate 프로퍼티는 말 그대로 DatePicker에서 표시할 날짜의 범위를 정한다.  
builder 프로퍼티는 테마를 설정할 때 사용한다. Theme클래스를 사용하여 다크 테마를 적용할 수 있다.  
builder프로퍼티를 정의하지 않으면 기본 형태로 표시된다.  
showDatePicker() 함수가 반환하는 Future<DateTime>타입은 미래에 DateTime 타입의 데이터를 받는다는 것을 정의한 특별한 타입이다.  
Future 타입은 값이 결정될 때까지 코드가 블록되며 then()메서드를 통해 값이 결정되었을 때의 처리를 할 수 있다.  
오래 걸리는 처리를 할 때 사용한다.  
버튼을 클릭하면 다크 모드의 DatePicker를 표시하고 선택한 날짜를 화면에 표시해본다.  
상태가 있으므로 StatefulWidget으로 작성한다.
```dart
//State 클래스의 필드에 작성
DateTime _selectedTime;

...생략...
//Scaffold의 body에 작성
Column(
    children: <Widget> [
        ElecatedButton(
            onPressed: () {
                Future<DateTime> selectedDate = showDatePicker(
                    context: context,
                    initialDate: DateTime.now(), //초깃값
                    firstDate: DatteTime(2018), //시작일
                    lastDate: DateTime(2030), //마지막일
                    builder: (BuildContext context, Widget child) {
                        return Theme(
                            data: ThemeData.dark(),
                            child: child,
                        );
                    },
                );
                //여기서 사용자가 날짜를 선택할 때까지 코드가 블록
                selectedDate.then((dateTime) {
                    setState((){
                        _selectedTime = dateTime;
                    });
                });
            },
            child: Text('Date Picker'),
        ),
        Text('$_selectedTime'),
    ],
),

```
Future 타입은 then() 메서드를 사용해 결과를 받는 함수를 작성할 수 있다.  
날짜가 선택되면 _seletedTime 변수를 갱신하고 setSate()함수를 호출하여 표시한다.
## TimePicker
시간을 선택할 때 사용하는 위젯  
showTimePicker()함수를 호출하면 타임 피커를 표시할 수 있다.
```dart
Future<TimeOfDay> selectedTime = showTimePicker(
    initialTime: TimeOfDay.now(),
    context: context,
);
```
initialTime 프로퍼티에 초깃값을 지정한다. TimeOfDay.now()함수를 사용하면 현재 시간을 설정하게 된다.  
context가 필요하며 Future타입으로 TimeOfDay 타입의 값을 반환한다. TimeOfDay 클래스에는 시간과 분 정보가 들어 있다.  
버튼을 클릭하면 TimePicker를 표시하고 선택한 시간을 화면에 표시한다.  
상태를 가지므로 StatefulWidget으로 작성해야한다.
```dart
//State 클래스의 필드에 작성
String _selectedTime;

...생략...
//Scaffold의 body에 작성
Column(
    children: <Widget>[
        ElevatedButton(
            onPressed: () {
                Future<TimeOfDay> selectedTime = showTimePicker(
                    initialTime: TimeOfDay.now(),
                    context: context,
                );
                //여기서 사용자가 시간을 선택할 때까지 코드가 블록됨

                selectedTime.then((timeOfDay) {
                    setState(() {
                        _selectedTime = '${timeOfDay.hour}:${timeOfDay.minute}';
                    });
                });
            },
            child: Text('Time Picker'),
        ),
        Text('$_selectedTime'),
    ],
),

```
날짜가 선택되면 timeOfDay.hour, timeOfDay.minute에서 시간과 분을 얻을 수 있다.  
setState()함수를 호출하여 `Text('$_selectedTime'),`에 표시한다.
# 이벤트
onTap, onPressed등의 이벤트를 기본 프로퍼티로 가지고 있지 않은 위젯에 이벤트를 적용할 수 있도록 해주는 위젯을 설명한다.
## GestureDetector와 InkWell
글자나 그림 같이 이벤트 프로퍼티가 없는 위젯에 이벤트를 적용하고 싶을 때 사용하는 위젯이다.  
GestureDetector와 InkWell위젯은 터치 이벤트를 발생시킨다. onTap프로퍼티를 가지고 있어서 child프로퍼티에 어떠한 위젯이 와도 클릭 이벤트를 작성할 수 있다. 따라서 Text, Image 등의 위젯에도 간단히 클릭 이벤트를 추가할 수 있다.
```dart
GestureDetector(
    onTap: () {
        //클릭 시 실행
    },
    child: [위젯],
),

InWell(
    onTap: () {
        //클릭 시 실행
    },
    child: [위젯],
),
```
InkWell위젯으로 감싸고 클릭하면 물결 효과가 나타나지만 GestureDetector위젯은 그렇지 않다.
```dart
Column(
    mainAxisAlignment: MainAxisAlignment.center,
    children: <Widget>[
        GestureDetector(
            onTap: () {
                print('GestureDetector 클릭!');
            },
            child: Text('클릭!!'),
        ),
        SizedBox(
            height: 40,
        ),
        InkWell(
            onTap: () {
                print('GestureDetector 클릭!');
            },
            child: Text('클릭!!'),
        ),
    ],
),
```
# 애니메이션
## Hero
Hero위젯은 화면 전환시 자연스럽게 연결되는 애니메이션을 지원한다.  
이전 화면으로 돌아갈 때도 자연스럽게 애니메이션이 동작한다.  
Hero위젯 사용 방법은 애니메이션 효과의 대상이 되는 양쪽 화면의 위젯을 Hero위젯으로 감싸고 tag 프로퍼티를 반드시 동일하게 지정해야한다.
```dart
//첫번째 페이지
class HeroPage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Sacffold(
            appBar: AppBar(
                title: Text('Hero'),
            ),
            body: Center(
                child: GestureDetector(
                    onTap: () {
                        Navigator.push(
                            context,
                            MaterialPageRoute(builder: (context) => HeroDetailPage()),
                        );
                    },
                    child: Hero(
                        tag: 'image', //여기서 작성한 태그와 두 번째 페이지의 태그가 동일해야한다.
                        child: Image.asset(
                            'assets/sample.jpg',
                            width: 100,
                            height: 100,
                        ),
                    ),
                ),
            ),
        );
    }
}

//두번째 페이지
class HeroDetailPage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('Hero Detail'),
            ),
            body: Hero(
                tag: 'image', //여기서 작성한 태그와 첫 번째 페이지의 태그가 동일해야 한다.
                child: Image.asset('assets/sample.jpg'),
            ),
        );
    }
}
```
## AnimatedContainer
Hero 위젯이 화면 전환시 애니메이션 효과를 지원했다면 AnimatedContainer 위젯은 한 화면내에서 setState()함수를 호출하여 화면을 새로 그릴 떄 변경된 프로퍼티에 의해 애니메이션 되도로 해준다.  
Container 위젯과 쓰임새는 비슷하지만 duration, curve등의 애니메이션 관련 프로퍼티가 있다.  
duration 프로퍼티는 필수이며 애니메이션되는 데 걸리는 시간을 Duration클래스를 사용해 정의할 수 있다.  
Curves 클래스에는 미리 정의된 애니메이션 효과가 있다.
```dart
AnimatedContainer(
    duration: Duration(seconds: 1), //1초 동안 애니메이션 적용
    width: 100.0,                   // 가로 길이 
    height: 150.0,                  // 세로 길이
    child: [위젯],
    curve: Curves.fastOutSlowIn, //미리 정의된 애니메이션 효과
),
```
다음은 100x100크기의 이미지를 탭하면 100~299 크기로 랜덤하게 크기가 변경되어 애니메이션되는 예시이다.  
상태를 변경시키면서 애니메이션이 적용되므로 StatuefulWidget으로 작성한다.
```dart
import 'dart:math'; //random 클래스에 사용

...생략...

class _AnimatedContainerPageState extends State<AnimatedContainerPage> {
    var _size = 100.0;

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: AppBar(
                title: Text('AnimatedContainer'),
            ),
            body: Center(
                child: GestureDetector(
                    onTap:() {
                        final random = Random();
                        setState(() {
                            //클릭할 때 마다 100.0 ~ 299.사이의 실수 랜덤
                            _size = random.nextInt(200).toDouble()+100;
                        });
                    },
                    child: AnimatedContainer(
                        duration: Duration(seconds: 1),
                        width: _size
                        height: _size,
                        child: Image.asset('assets/sample.jpg'),
                        curve: Curves.fastOutSlowIn,
                    ),
                ),
            ),
        );
    }
}
```
**랜덤값 계산식**
랜덤 함수의 역할과 왜 100.0~299.0 사이의 난수가 발생하는가
1. nextInt(200) : 0 ~ 199 사이의 난수를 정수로 반환
2. toDouble() : 정수를 실수로 변환 => 0.0~199.0
3. + 100 : 100 씩 더함 => 100.0 ~ 299.0
AnimatedContainer의 width, height 프로퍼티가 double을 받기 때문에 실수로 변경했다.  
setState()함수에 의해 다시 그려질 때 AnimatedContainer 위젯은 이전 _size 값에서 새로 갱신된 _size값까지 1초 동안 fastOutSlowIn에 정의된 효과가 적용되며 애니메이션 된다.
## SliverAppBar와 SliverFillRemaining
SliverAppBar와 SliverFillRemaining은 화면 헤더를 동적으로 표현하는 위젯이다.  
헤더를 위로 스크롤하면 헤더 부분이 작아지면서 헤더 하단에 있던 정적인 내용만 보이는 AppBar형태로 애니메이션된다.  
이런 효과를 Sliver효과라고 부른다.
```dart
class SliverPage extends StatelessWidget {
    @override
    Widget build(BuildContext context) {
        return Scaffold(
            slivers: <Widget> [
                SliverAppBar( //헤더영역
                    pinned: true, //축소시 상단에 AppBar가 고정되는지 설정
                    expandedHeight: 180, 0 //헤더의 최대 높이
                    flexibleSpace: FlexibleSpaceBar( //늘어나는 영역의 UI 정의
                        title: Text('Sliver'),
                        background: Image.asset(
                            'assets/sample.jpg',
                            fit: BoxFit.cover,
                        ),
                    ),
                ),
                SliverFillRemaining( //내용 영역
                    child: Center (
                        child: Text('center'),
                    ),
                ),
            ],
        );
    }
}
```
Scaffold의 appBar를 지정하지 않고 body에 CustomScrollView의 인스턴스를 지정했다.  
그리고 CustomScrollView의 slivers프로퍼티에 SliverAppBar와 SliverFillRemaing위젯을 설정했다.  
SliverAppBar 위젯의 Sliver효과를 위한 최소한의 프로퍼티는 pinned, expandedHeight, flexibleSpace이다. 
- pinned: 축소될 떄 상단에 AppBar가 고정될지 사라질지 설정
- expandedHeight: 확대될 때의 최대 높이
- flexibleSpace: 확대/축소되는 영역의 UI 작성
flexibleSpace위젯은 title와 background 프로퍼티를 활용하여 적절히 AppBar 영역이 확장되었을 때의 UI를 작성한다.  
SliverFillRemaing위젯에는 스크롤 영역에 표시될 화면을 정의한다.  
child에 작성한 내용의 크기가 작아도 SliverAppBar부분이 추소될 때 하나의 크기가 알아서 결정된다.
## SliverAppBar와 SliverList
SliverFillRemaining위젯은 하나의 정적인 화면을 구성할 떄 사용하는 반면 SliverList를 사용하면 ListView를 사용하며 Sliver효과를 준다.
```dart
class SliverListPage extends StatelessWidget {
    //'No.0'에서 'No.49'까지 표시하는 ListTitle을 담은 리스트
    final _items = List.generate(50, (i) => ListTile(title: Text('No. $i')));

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            body: CustomScrollView(
                slivers: <Widget>[
                    SliverAppBar(
                        pinned: true,
                        expandeHeight: 180.0,
                        flexibleSpace: FlexibleSpaceBar(
                            title: Text('Sliver'),
                            background: Image.asset(
                                'assets/sample.jpg',
                                fit: BoxFit.cover,
                            ),
                        ),
                        actions: <Widget>[
                            IconButton(
                                icon: Image.asset('assets/github_icon.png'),
                                onPressed: () {},
                            )
                        ],
                    ),
                    SliverList(
                        delegate: SliverChildListDelegate(_items),
                    ),
                ],
            ),
        );
    }
}
```
SliverList는 delegate 프로퍼티에 SliverChildListDelegate클래스 인스턴스를 지정해야한다.
SliverChildListDelegate 클래스의 생성자에 표시할 위젯 리스트(_items)를 인수로 전달해야 하며 _items는 ListTitle이 50개(0~49)인 리스트다. 
# 쿠퍼티노 디자인
[머티리얼 디자인](https://material.io/design/)은 안드로이드에 적용하려고 구글이 만든 디자인 규칙이므로 아이폰에는 어울리지 않는다.  
아이폰스러운 디자인을 적용하려면 [쿠퍼티노 디자인](https://developer.apple.com/design/)을 사용한다.  
flutter/cupertino.dart패키지에는 다양한 쿠퍼티노 디자인용 UI위젯이 준비되어 있다.  
쿠퍼티노로 시작하는 이름의 클래스들이 이에 해당하며 사용 방법이 머티리얼 위젯과 비슷하므로 쉽게 적용할 수 있어 재미있게도 머티리얼 디자인과 쿠퍼티노 디자인 콘셉트를 섞어서 사용할 수 있고 안드로이드 앱을 아이폰스럽게 만드는 것도 가능하다.
## 쿠퍼티노 기본 UI
쿠퍼티노 디자인에서는 AppBar대신 CupertinoNavigationBar를 사용하며 CupertinoSwitch, CupertinoButton 등을 사용한다.
```dart
import 'package:flutter/cupertino.dart'; //쿠퍼티노 위젯
import 'package:flutter/material.dart';  //머티리얼 위젯

//MyApp클래스 동일

class MyHomePage extends StatefulWidget {
    @override
    _MyHomePageState createState() => _MyHomePageState();
}

class _MyHomagePageState extends State<MyHomePage> {
    var _isOn = false;

    @override
    Widget build(BuildContext context) {
        return Scaffold(
            appBar: CupertinoNavigationBar(        //머티리얼의 AppBar에 대응
                middle: Text('4.10 쿠퍼티노 디자인'),  //머티리얼 AppBar에 Title대응
            ),
            boday: Column(
                children: <Widget>[
                    CupertinoSwitch( //Switch에 대응
                        value: _isOn,
                        onChanged: (bool value) {
                            setState((){
                                _isOn = value;
                            });
                        },
                    ),
                    CupertinoButton(    //ElevatedButton에 대응
                        borderRadius: BorderRadius.circular(16.0),
                        color: Colors.orange,
                        child: Text('쿠퍼티노 AlertDialog'),
                        onPressed: () {
                            //클릭 이벤트
                        },
                    ),
                    CupertionButton(
                        child: Text('쿠퍼티노 Picker'),
                        onPressed: () {
                            //클릭 이벤트
                        },
                    ),
                ],
            ),
        );
    }

    _showCupertinoDialog() {
        //CupertionAlertDialog, 뒤에서 작성
    }

    _showCupertinoPicker() {
        //CupertinoPicker, 뒤에서 작성
    }
}

```
먼저 CupertinoNavigationBar위젯은 머티리얼의 AppBar위젯에 대응한다. leading, middle, trailing 프로퍼티는 각각 왼쪽, 가운데, 오른쪽 영역을 나타내며 middle프로퍼티에는 주로 제목을 표시한다.  
CupertinoSwitch는 머티리얼의 Switch와 사용 방법이 동일하다.  
참고로 쿠퍼티노 디자인에서는 체크박스나 라디오 버튼이 따로 없고 스위치만 사용한다.  
쿠퍼티노 디자인의 ElevatedButton버튼에 대응하는 것으로 CupertinoButton위젯이 제공된다.
## CupertinoAlertDialog
기본적인 사용 방법은 머티리얼의 AlertDialog와 같다.  
showDialog()함수의 builder 프로퍼티에 CupertinoAlertDialog위젯 인스턴스를 지정한다.  
actions 프로퍼티에는 어떠한 위젯도 가능하지만 주로 CupertinoDialogAction위젯의 인스턴스를 지정한다.
```dart
showDialog(
    context: context,
    builder: (context) => CupertinoAlertDialog(
        title: [위젯],
        content: [위젯],
        actions: <Widget>[
            CupertinoDialogAction(...생략...),
            CupertinoDialogAction(...생략...),
        ],
    ),
);
```
기본적인 사용 방법은 머티리얼의 AlertDialog와 동일하지만, showDialog()함수의 프로퍼티에 CupertinoAlertDialog인스턴스를 반환하는 것이 다르다.
```dart
_showCupertinoDialog() {
    showDialog(
        context: context,
        builder: (context) => CupertinoAlertDialog( //인스턴스 반환
            title: Text('제목'),
            content: Text('내용'),
            actions: <Widget>[
                CupertinoDialogAction(
                    child: Text('Cancel'),
                ),
                CupertinoDialogAction(
                    child: Text('Ok'),
                    onPressed: () {
                        Navigator.of(context).pop(); //다이어그램 닫기
                    },
                ),
            ],
        ),
    );
}
```
## CupertinoPicker
iOS에서 자주 사용되는 피커이다.  
위 아래로 스크롤하고 피커 바깥을 클릭하면 선택한 값이 적용된다.  
```dart
showCupertinoModalPopup(
    context: context,
    builder: (context) => Container(
        height: [double 값], //피커의 높이를 정해 줌
        child: CupertinoPicker(
            children: <Widget>[...생략...],
            itemExtent: [double 값], //표시할 항목의 높이
            onSelectedItemChanged: (int value) {
                //선택한 항목의 인덱스 value를 처리
            },
        ),
    ),
);
```
showCupertinoModalPopup() 함수를 사용하고 builder 프로퍼티에 CupertinoPicker위젯을 적용한다.  
기본적으로 전체 화면 크기가 되므로 Container 위젯으로 감싸고 높이를 조절하면 하단의 일부가 되도록 할 수 있다.  
onSeletedItemChanged 프로퍼티에 작성한 함수는 피커의 바깥 부분을 클릭했을 때 피커가 닫히면서 호출된다.  
이때 호출되는 함수의 인수인 value는 선택된 값의 인덱스 번호이다.
```dart
_showCupertinoPicker() async {
    //0부터 9까지 숫자 리스트 생성
    final _items = List.generate(10, (i) => i);
    var result = _items[0]; //기본값

    await showCupertinoModalPopup(
        context: context,
        builder: (context) => Container(
            height: 200.0, //피커 높이
            child: CupertinoPicker(
                children: _items.map((e) => Text('No. $e')).toList(), //0~9 숫자 표시 
                itemExtent: 50.0, //항목 1개의 높이는 50
                onSelectedItemChanged: (int value) {
                    result = _items[value];
                },
            ),
        ),
    );
    print(result);
}
```
showCupertinoModalPopup() 함수는 Future타입을 반환하기 때문에 await 키워드를 사용하여 피커가 닫힐 때까지 대기한 후 result변수의 값을 출력한다.  
await 키워드를 사용하려면 메서드 선언시 async키워드를 사용해야한다.

### 마치며
- 애니메이션용 위젯을 감싸면 애니메이션도 비교적 간단히 구현할 수 있다.
- cupertino.dart 패키지를 임포트하면 쿠퍼티노 디자인용 위젯을 사용할 수 있다.
- future는 비동기 작업의 결과를 나타내며 미완료(value를 생성하기 전)또는 완료(value 생성)의 두 가지 상태를 가질 수 있습니다.